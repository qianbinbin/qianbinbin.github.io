<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>二叉树非递归遍历算法的快速实现&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="二叉树非递归遍历算法的快速实现"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">二叉树非递归遍历算法的快速实现</h1><p class="article date">2018-03-25</p></section><article class="article markdown-body"><p>二叉树的递归遍历简洁明了，而非递归遍历则相对复杂，三种递归思路有很大区别，还容易忘。如果不用线索二叉树的话，一般要用栈来实现，即便都是用栈实现，实现思路也有差别，这给我们理解和记忆带来困扰。</p><p>本文介绍利用栈来实现的二叉树非递归算法，主要目的是快速实现，而不是详细解释。</p><h2 id=先序遍历>先序遍历</h2><p>递归算法的伪代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>preorder</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>=</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl>  <span class=n>visit</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>preorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>preorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></div><p>首先我们知道，栈用来存储已经经过，但是还未到访问时机的结点。</p><p>先序遍历的顺序是：根 - 左 - 右，当处理一个结点时，当前结点可以直接访问，而左右子树还未到处理时机，需要将子树的根结点压入栈中：先压入右子结点，再压入左子结点。下次迭代再从栈中取出并处理，这样就保证了 根 - 左 - 右 的访问顺序。</p><p>伪代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>iterativePreorder</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>=</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl>  <span class=n>s</span> <span class=err>←</span> <span class=n>empty</span> <span class=n>stack</span>
</span></span><span class=line><span class=cl>  <span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=ow>not</span> <span class=n>s</span><span class=o>.</span><span class=n>isEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span> <span class=err>←</span> <span class=n>s</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>visit</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span><span class=n>right</span> <span class=n>child</span> <span class=ow>is</span> <span class=n>pushed</span> <span class=n>first</span> <span class=n>so</span> <span class=n>that</span> <span class=n>left</span> <span class=ow>is</span> <span class=n>processed</span> <span class=n>first</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=中序遍历>中序遍历</h2><p>递归算法伪代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>=</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl>  <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>visit</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></div><p>中序遍历的顺序为 左 - 根 - 右，在处理一个结点时，要先处理它的左子树，再访问本身，再处理右子树。那么就要先把自身压入栈中，然后处理左子树，即指针指向左子结点。</p><p>当指针为空，可以把指针指向的地方当成一棵树，并认为这棵树已经访问完毕，</p><ul><li><p>如果这棵树是它父结点的左子树，接下来就应该访问父结点，即栈顶元素</p></li><li><p>如果这棵树是它父结点的右子树，说明以父结点为根的子树已经全部访问完毕，接下来就应该访问父结点向上首个还未访问的祖先结点，同样是栈顶元素</p></li></ul><p>总之直接出栈访问即可。</p><p>当访问某个结点时，它的左子树必定已经访问完毕，接下来要处理的是右子树，就将指针指向右子结点。</p><p>伪代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>iterativeInorder</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>s</span> <span class=err>←</span> <span class=n>empty</span> <span class=n>stack</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=ow>not</span> <span class=n>s</span><span class=o>.</span><span class=n>isEmpty</span><span class=p>()</span> <span class=ow>or</span> <span class=n>node</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>node</span> <span class=err>←</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>node</span> <span class=err>←</span> <span class=n>s</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=n>visit</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>node</span> <span class=err>←</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span>
</span></span></code></pre></div><p>很多实现会做一些优化，用几个嵌套的<code>while</code>循环，其实不利于理解。</p><p>如果把先序遍历写成和中序遍历风格一致的话：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>iterativePreorder</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>=</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl>  <span class=n>s</span> <span class=err>←</span> <span class=n>empty</span> <span class=n>stack</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=ow>not</span> <span class=n>s</span><span class=o>.</span><span class=n>isEmpty</span><span class=p>()</span> <span class=ow>or</span> <span class=n>node</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>visit</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>node</span> <span class=err>←</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>node</span> <span class=err>←</span> <span class=n>s</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span><span class=o>.</span><span class=n>right</span>
</span></span></code></pre></div><p>不同的是这时栈中保存的就是已经访问过的结点了。</p><h2 id=后序遍历>后序遍历</h2><p>递归算法伪代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>postorder</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>=</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl>  <span class=n>postorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>postorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>visit</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span></code></pre></div><p>后序遍历的顺序为 左 - 右 - 根，在处理一个结点时，要先处理它的左右子树，再访问本身，那么就要先把自身压入栈中，然后把指针指向左子结点。</p><p>当指针为空，可以把指针指向的地方当成一棵树，并认为这棵树已经访问完毕，</p><ul><li><p>如果这棵树是父结点的左子树，接下来就应该处理父结点的右子树，父结点即栈顶元素</p></li><li><p>如果这棵树是父结点的右子树，接下来就应该访问父结点，即栈顶元素</p></li></ul><p>麻烦之处在于，当处理栈顶元素时，此结点的左子树已经处理完毕，我们并不知道它的右子树是否已经处理，这时可以用一个指针指向上一次访问的结点，根据后序遍历的性质，结点右子树最后一个访问的结点必定是这个右子树的根结点，也就是结点的右子结点。如果这个右子结点已经访问，那么说明左右子树全部处理完毕，接下来出栈并访问此结点即可，否则就不要出栈，而让指针指向右子结点。</p><p>伪代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>iterativePostorder</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>s</span> <span class=err>←</span> <span class=n>empty</span> <span class=n>stack</span>
</span></span><span class=line><span class=cl>  <span class=n>lastNodeVisited</span> <span class=err>←</span> <span class=n>null</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=ow>not</span> <span class=n>s</span><span class=o>.</span><span class=n>isEmpty</span><span class=p>()</span> <span class=ow>or</span> <span class=n>node</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>node</span> <span class=err>←</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>peekNode</span> <span class=err>←</span> <span class=n>s</span><span class=o>.</span><span class=n>peek</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=o>//</span> <span class=k>if</span> <span class=n>right</span> <span class=n>child</span> <span class=n>exists</span> <span class=ow>and</span> <span class=n>traversing</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>      <span class=o>//</span> <span class=kn>from</span> <span class=nn>left</span> <span class=n>child</span><span class=p>,</span> <span class=n>then</span> <span class=n>move</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>peekNode</span><span class=o>.</span><span class=n>right</span> <span class=err>≠</span> <span class=n>null</span> <span class=ow>and</span> <span class=n>lastNodeVisited</span> <span class=err>≠</span> <span class=n>peekNode</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=err>←</span> <span class=n>peekNode</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>visit</span><span class=p>(</span><span class=n>peekNode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>lastNodeVisited</span> <span class=err>←</span> <span class=n>s</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span></code></pre></div><h3 id=双栈法>双栈法</h3><p>如果使用两个栈，则后序遍历会简单很多。</p><p>栈<code>s1</code>存储等待处理的子树的根结点，<code>s2</code>存储等待访问的结点。</p><p>当处理一个子树时，将其根结点从<code>s1</code>中出栈，压入<code>s2</code>，此结点的左右子结点依次压入<code>s1</code>，这样就保证了先左后右的处理顺序。</p><p><code>s2</code>总是先存储根结点，它的进栈顺序和遍历结果是相反的，出栈顺序则相同，因此可以得到后序遍历序列。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>iterativePostorder</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>s1</span> <span class=err>←</span> <span class=n>empty</span> <span class=n>stack</span>
</span></span><span class=line><span class=cl>  <span class=n>s1</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>s2</span> <span class=err>←</span> <span class=n>empty</span> <span class=n>stack</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=ow>not</span> <span class=n>s1</span><span class=o>.</span><span class=n>isEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span> <span class=err>←</span> <span class=n>s1</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>s1</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span> <span class=err>≠</span> <span class=n>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>s1</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>s2</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=ow>not</span> <span class=n>s2</span><span class=o>.</span><span class=n>isEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>visit</span><span class=p>(</span><span class=n>s2</span><span class=o>.</span><span class=n>pop</span><span class=p>())</span>
</span></span></code></pre></div><h2 id=参考资料>参考资料</h2><ol><li><a href=https://en.wikipedia.org/wiki/Tree_traversal target=_blank rel="noopener noreferrer">Tree traversal - Wikipedia</a></li></ol></article><section class="article labels"><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a><a class=tag href=/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/>二叉树</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/unique-binary-search-trees-ii/><span class="iconfont icon-article"></span>批量构建二叉查找树时的一个常见错误</a></p><p><a class=link href=/posts/cycle-detection/><span class="iconfont icon-article"></span>Floyd 判圈算法</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>