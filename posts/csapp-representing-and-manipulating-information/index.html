<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>CSAPP 信息的表示和处理&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="CSAPP 信息的表示和处理"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">CSAPP 信息的表示和处理</h1><p class="article date">2018-12-25</p></section><article class="article markdown-body"><h2 id=21-信息存储>2.1 信息存储</h2><h3 id=211-十六进制表示法>2.1.1 十六进制表示法</h3><p>十六进制转换窍门：记住 A、C 和 F 对应的值，B、D 和 E 可通过计算它们与前三个值的相对关系来完成。</p><p>对于 2 的非负整数 n 次幂 x，即 $x = 2^n$，一个转换为十六进制的技巧：x 的二进制形式就是 1 后面跟 n 个 0，把 n 表示成 $i + 4j$，其中 $0 \le i \le 3$，当 i 为 0、1、2、3 时，x 的十六进制开头数字分别为 1、2、4、8，后面跟着 j 个十六进制的 0。如 $2048 = 2 ^ {11}$，有 $n = 11 = 3 + 4 \cdot 2$，从而得到十六进制 0x800。</p><h3 id=212-字数据大小>2.1.2 字数据大小</h3><p>大多数 64 位机器也可以运行 32 位机器编译的程序，这是一种向后兼容。例如 <code>prog.c</code> 用如下伪指令编译后</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ gcc -m32 prog.c
</span></span></code></pre></div><p>该程序就可以在 32 位或 64 位机器上正确运行。若用如下伪指令编译</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ gcc -m64 prog.c
</span></span></code></pre></div><p>就只能在 64 位机器上运行。</p><p>C 语言的数据类型中，<code>int</code> 即使是为 64 位系统编译，通常也只有 4 个字节，<code>long</code> 一般在 32 位程序中为 4 字节，64 位程序中则为 8 字节。</p><p>ISO C99 引入了一类数据类型，其数据长度是固定的，不随编译器和机器设置变化，例如 <code>int32_t</code> 和 <code>int64_t</code> 分别为 4 个字节和 8 个字节。</p><p>大多数编译器将 <code>char</code> 类型视为有符号数，但 C 标准不保证这一点，程序员应该用 <code>signed char</code> 来保证它为有符号数值。不过在很多情况下，<code>char</code> 是否有符号并不敏感。</p><h3 id=213-寻址和字节顺序>2.1.3 寻址和字节顺序</h3><p>在几乎所有机器上，多字节对象被存储为连续的字节序列，对象的地址是所使用字节中最小的地址。</p><ul><li>小端法：按照从最低有效字节到最高有效字节的顺序存储对象</li><li>大端法：按照从最高有效字节到最低有效字节的顺序存储对象</li></ul><p><code>man ascii</code> 可查询 ASCII 字符码表。</p><h3 id=217-c-语言中的位级运算>2.1.7 C 语言中的位级运算</h3><p><code>~0</code>可以生成一个全 1 的掩码，不管机器的字长是多少。</p><p><code>x ^ ~0xff</code> 可以把除最低字节以外的位取反（取补）。</p><p><code>x ^ y</code> 等价于 <code>(x & ~y) | (~x & y)</code></p><h3 id=219-c-语言中的移位运算>2.1.9 C 语言中的移位运算</h3><p>C 语言左移 <code>&lt;&lt;</code> 都是逻辑左移，没有算数左移。</p><p>逻辑右移是在左端补 0，算数右移是在左端补最高有效位的值。</p><p>C 语言标准并没有明确规定对于有符号数应该使用哪种类型的右移，但几乎所有的编译器/机器组合都对有符号数使用算数右移，对于无符号数必定是逻辑右移。</p><p>Java 对如何右移有明确定义，<code>>></code> 是算数右移，<code>>>></code> 是逻辑右移。</p><p>如果移位量 k 大于数据类型的位数 w，即 $k \ge w$，按照 C 标准实际上位移量是 $k\ mod\ w$，但这种行为对于 C 程序来说是没有保证的。而 Java 则保证这一点。</p><h2 id=22-整数表示>2.2 整数表示</h2><h3 id=222-无符号数的编码>2.2.2 无符号数的编码</h3><p>$$B2U_w(x) = \sum_{i=0}^{w-1} x_i2^i$$</p><h3 id=223-补码编码>2.2.3 补码编码</h3><p>$$B2T_w(x) = -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2} x_i2^i$$</p><p>C 语言标准并没有要求使用补码形式来表示有符号整数，但几乎所有机器都是这么做的。</p><p><code>limits.h</code> 定义了不同整型数据类型的取值范围，<code>stdint.h</code> 中定义了不同长度的有符号和无符号整数及其取值范围，<code>inttypes.h</code> 中定义了打印确定宽度类型的所需的宏。</p><p>Java 对整数类型的取值范围和表示是非常明确的，它要求采用补码表示。其单字节数据类型为 <code>byte</code> 而不是 <code>char</code>。</p><h3 id=224-有符号数和无符号数之间的转换>2.2.4 有符号数和无符号数之间的转换</h3><p>补码转无符号数：</p><p>$$T2U_w(x) = \begin{cases} x + 2^w, & x &lt; 0 \\ x, & {x \ge 0} \end{cases} \\ = x + x_{w-1}2^w$$</p><p>无符号数转补码：</p><p>$$U2T_w(u) = \begin{cases} u, & u \le TMax_w \\ u - 2^w, & u > TMax_w \end{cases} \\ = -u_{w-1}2^w + u$$</p><h3 id=225-c-语言中的有符号数与无符号数>2.2.5 C 语言中的有符号数与无符号数</h3><p>C 语言创建一个无符号常量，必须加上后缀字符 <code>U</code> 或 <code>u</code>，例如 <code>12345U</code> 或者 <code>0x1A2Bu</code>。</p><p>C 语言允许无符号数和有符号数之间的转换，C 标准没有精确规定应如何进行这种转换，但大多数系统遵循的原则是底层的位表示保持不变，即应用 $U2T_w$ 和 $T2U_w$。</p><p>当用 <code>printf</code> 输出数值时，分别用指示符 <code>%d</code>、<code>%u</code> 和 <code>%x</code> 以有符号十进制、无符号十进制和十六进制格式输出一个数字，<code>printf</code> 没有使用任何类型信息。</p><p>当执行一个运算时，如果它的一个运算数是有符号的，另一个是无符号的，C 语言会隐式地将有符号数强制转换为无符号数，并假设这两个数都是非负的，来执行这个运算。例如假设 <code>int</code> 表示为 32 位补码，<code>-1 &lt; 0U</code> 等价于 <code>429467295U &lt; 0U</code>，结果为非。</p><p>32 位补码表示的 <code>int</code> 最小值 $TMin_{32}$ 通常写成 -2147483647 - 1，而不是 -2147383648 或 0x80000000。<code>limits.h</code> 中是这样定义的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define	INT_MAX		2147483647	</span><span class=cm>/* max value for an int */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define	INT_MIN		(-2147483647-1)	</span><span class=cm>/* min value for an int */</span><span class=cp>
</span></span></span></code></pre></div><p>解释可参考 <a href=https://stackoverflow.com/questions/26003893/why-do-we-define-int-min-as-int-max-1 target=_blank rel="noopener noreferrer">c - Why do we define INT_MIN as -INT_MAX - 1? - Stack Overflow</a>，简而言之，<code>-2148473648</code> 不是一个 <code>int</code> 常量，而是由一元操作符 <code>-</code> 和常量 <code>2147483648</code> 组合而成，而后者超过了 <code>int</code> 范围，在 32 位系统中是 <code>long long</code>，在 64 位系统中是 <code>long</code>。</p><h3 id=226-扩展一个数字的位表示>2.2.6 扩展一个数字的位表示</h3><p>无符号数的零扩展：将一个无符号数转换为一个较长的数据类型，只要在开头添加 0。</p><p>补码数的符号扩展：将一个补码数转换为一个较长的数据类型，在开头添加最高有效位的值。</p><p>推导：要证明</p><p>$$B2T_{w+k}([x_{w-1}, &mldr;, x_{w-1}, x_{w-1}, x_{w-2}, &mldr;, x_0]) = B2T_w([x_{w-1}, x_{w-2}, &mldr;, x_0])$$</p><p>只需证明</p><p>$$B2T_{w+1}([x_{w-1}, x_{w-1}, x_{w-2}, &mldr;, x_0]) = B2T_w([x_{w-1}, x_{w-2}, &mldr;, x_0])$$</p><p>将左边展开：</p><p>$$
B2T_{w+1}([x_{w-1}, x_{w-1}, x_{w-2}, &mldr;, x_0]) \\ = -x_{w-1}2^w + \sum_{i=0}^{w-1}x_i2^i \\ = -x_{w-1}2^w + x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i \\ = -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i \\ = B2T_w([x_{w-1}, x_{w-2}, &mldr;, x_0])
$$</p><p>归纳即可证明。</p><p>C 语言标准规定，先作位扩展，再作有符号和无符号数之间的转换。例如，把 <code>short</code> 类型的变量 <code>sx</code> 转换为 <code>unsigned</code> 类型，<code>(unsigned) sx</code> 等价于 <code>(unsigned) (int) sx</code>，而不是 <code>(unsigned) (unsigned short) sx</code>。</p><h3 id=227-截断数字>2.2.7 截断数字</h3><p>将较长类型转换为较短类型，直接去掉高位。</p><h2 id=23-整数运算>2.3 整数运算</h2><h3 id=231-无符号加法>2.3.1 无符号加法</h3><p>无符号整数 $x$ 和 $y$ 相加，把和 $x + y$ 截断为 $w$ 位得到无符号数结果。</p><p>$$x +_w^u y = \begin{cases} x + y, & x + y &lt; 2^w \\ x + y - 2^w, & 2^w \le x + y &lt; 2^{w+1} \end{cases}$$</p><p><strong>原理</strong>：检测无符号数加法中的溢出：</p><p>对在范围 $0 \le x, y \le UMax_w$ 中的 $x$ 和 $y$，令 $s = x +_w^u y$，则当且仅当 $s &lt; x$（或者等价地 $s &lt; y$）时发生了溢出。</p><p><strong>推导</strong>：</p><ol><li><p>$s &lt; x$ 和 $s &lt; y$ 必定同时成立或同时不成立。</p></li><li><p>如果 $s &lt; x$（或者等价地 $s &lt; y$），那么显然发生溢出。</p></li><li><p>如果发生了溢出，$s = x + y - 2^w$，由于 $y &lt; 2^w$，则 $s &lt; x$。</p></li></ol><p>C 语言实现：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/uadd_check.c style=color:lightslategrey;font-size:.8em>uadd_check.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>uadd_ok</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>x</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>&gt;=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p><strong>原理</strong>：无符号数的非</p><p>对满足 $0 \le x &lt; 2^w$ 的任意 $x$，其 $w$ 位无符号数的非</p><p>$$-_w^ux = \begin{cases} x, & x = 0 \\ 2^w - x, & x > 0 \end{cases}$$</p><h3 id=232-补码加法>2.3.2 补码加法</h3><p>两个 $w$ 位补码之和与无符号之和有完全相同的位级表示，大多数计算机使用同样的机器指令来执行无符号和有符号加法。把 $x + y$ 截断为 $w$ 位得到补码结果。</p><p><strong>原理</strong>：对 $-2^{w-1} \le x,y \le 2^{w-1} - 1$ 的整数 $x$ 和 $y$，有：</p><p>$$x +_w^t y = \begin{cases} x + y - 2^w, & 2^{w-1} \le x + y \\ x + y, & -2^{w-1} \le x + y &lt; 2^{w-1} \\ x + y + 2^w, & x + y &lt; -2^{w-1} \end{cases}$$</p><p><strong>推导</strong>：</p><p>$$x +_w^t y \\ = U2T_w(T2U_w(x) +_w^u T2U_w(y)) \\ = U2T_w[(x_{w-1}2^w + x + y_{w-1}2^w + y)\ mod\ 2^w] \\ = U2T_w[(x + y)\ mod\ 2^w] (x&rsquo; \cdot y&rsquo;)\ mod\ 2^w \\ = ((x + x_{w-1}2^w)(y + y_{w-1}2^w)\ mod\ 2^w \\ = (x \cdot y + (xy_{w-1} + yx_{w-1})2^w + 2^{2w})\ mod\ 2^w \\ = (x \cdot y)\ mod\ 2^w$$</p><p>设 $z = x + y$，$z&rsquo; = z \ mod\ 2^w$，$z&rsquo;&rsquo; = U2T_w(z&rsquo;) = x +_w^t y$，分 4 种情况讨论：</p><ol><li><p>$-2^w \le z &lt; -2^{w-1}$。$z&rsquo; = z + 2^w$，$0 \le z&rsquo; &lt; 2^{w-1}$，$z&rsquo;&rsquo; = z&rsquo; = x + y + 2^w$。此时必定有 $x &lt; 0$，$y &lt; 0$，$0 \le z&rsquo;&rsquo; &lt; 2^{w-1}$，两个负数相加，结果为非负，发生负溢出。</p></li><li><p>$-2^{w-1} \le z &lt; 0$。$z&rsquo; = z + 2^w$，$2^{w-1} \le z&rsquo; &lt; 2^w$，$z&rsquo;&rsquo; = z&rsquo; - 2^w = x + y$。</p></li><li><p>$0 \le z &lt; 2^{w-1}$。$z&rsquo; = z$，$z&rsquo;&rsquo; = z&rsquo; = x + y$。</p></li><li><p>$2^{w-1} \le z &lt; 2^w$。$z&rsquo; = z$，$2^{w-1} \le z&rsquo; &lt; 2^w$，$z&rsquo;&rsquo; = z&rsquo; - 2^w = x + y - 2^w$。此时必定有 $x > 0$，$y > 0$，$-2^{w-1} \le z&rsquo;&rsquo; &lt; 0$，两个正数相加，结果为负，发生正溢出。</p></li></ol><p><strong>原理</strong>：检测补码加法中的溢出：</p><p>对满足 $TMin_w \le x, y \le TMax_w$ 的 $x$ 和 $y$，令 $s = x +_w^t y$。当且仅当 $x > 0, y > 0$ 但 $s &lt; 0^{[注]}$ 时，发生了正溢出。当且仅当 $x &lt; 0, y &lt; 0$ 但 $s \ge 0$ 时，发生了负溢出。</p><blockquote><p>注：中英原文均为 $s \le 0$，但此时 $s = 0$ 的情况不可能发生。</p></blockquote><p><strong>推导</strong>：</p><ol><li><p>如果 $x > 0, y > 0$ 而 $s &lt; 0$，那么显然发生了正溢出。</p></li><li><p>如果发生了正溢出，必有 $x > 0, y > 0$（否则 $x + y &lt; TMax_w$，就不可能发生正溢出了），且 $s = x + y - 2^w &lt; 0$。</p></li></ol><p>同样的讨论也适用于负溢出的情况。</p><p>C 语言实现：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/tadd_check.c style=color:lightslategrey;font-size:.8em>tadd_check.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>tadd_ok</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>!</span><span class=p>(</span><span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>y</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>sum</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=o>!</span><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>y</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>sum</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>这里只用 <code>>= 0</code> 和 <code>&lt; 0</code>，只需取 <code>int</code> 符号位即可判断，不需要其他位。</p><h2 id=233-补码的非>2.3.3 补码的非</h2><p><strong>原理</strong>：补码的非：</p><p>对满足 $TMin_w \le x \le TMax_w$ 的 $x$，其补码的非</p><p>$$-_w^tx = \begin{cases} TMin_w, & x = TMin_w \\ -x, & x > TMin_w \end{cases}$$</p><p>计算补码位级表示的非的几种方法：</p><ul><li><p>对每一位取反，再对结果加 1。在 C 语言中，对于任意整数值 <code>x</code>，<code>-x</code> 和 <code>~x + 1</code> 的结果完全一样</p></li><li><p>找到最右边的 1，将其左边所有位取反</p></li></ul><h3 id=234-无符号乘法>2.3.4 无符号乘法</h3><p>把乘积 $x \cdot y$ 截断为 $w$ 位。</p><p><strong>原理</strong>：</p><p>对满足 $0 \le x, y \le UMax_w$ 的 $x$ 和 $y$ 有</p><p>$$x *_w^u y = (x \cdot y)\ mod \ 2^w$$</p><h3 id=235-补码乘法>2.3.5 补码乘法</h3><p>将乘积截断为 $w$ 位。</p><p><strong>原理</strong>：补码乘法</p><p>对满足 $TMin_w \le x, y &lt; TMax_w$ 的 $x$ 和 $y$，有：</p><p>$$x *_w^t y = U2T_w((x \cdot y)\ mod \ 2^w)$$</p><p>对于无符号和补码乘法来说，乘法运算的位级表示都是一样的。</p><p><strong>原理</strong>：无符号和补码乘法的位级等价性</p><p>给定长度为 $w$ 的位向量 $\vec{x}, \vec{y}, x = B2T_w(\vec{x}), y = B2T_w(\vec{y}), x&rsquo; = B2U_w(\vec{x}), y&rsquo; = B2U_w(\vec{y})$，则</p><p>$$T2B_w(x *_w^t y) = U2B_w(x&rsquo; *_w^u y&rsquo;)$$</p><p><strong>推导</strong>：</p><p>$x&rsquo; = x + x_{w-1}2^w, y&rsquo; = y + x_{w-1}2^w$，则</p><p>$$(x&rsquo; \cdot y&rsquo;)\ mod\ 2^w = ((x + x_{w-1}2^w)(y + y_{w-1}2^w)\ mod\ 2^w \\ = (x \cdot y + (xy_{w-1} + yx_{w-1})2^w + 2^{2w})\ mod\ 2^w \\ = (x \cdot y)\ mod\ 2^w$$</p><p>对补码乘法公式两边应用 $T2U_w$ 得</p><p>$$T2U_w(x *_w^t y) = (x \cdot y)\ mod \ 2^w = (x&rsquo; \cdot y&rsquo;) \ mod \ 2^w = x&rsquo; *_w^u y&rsquo;$$</p><p>再对等式两边同时应用 $U2B_w$ 得</p><p>$$T2B_w(x *_w^t y) = U2B_w(x&rsquo; *_w^u y&rsquo;)$$</p><p><strong>判断补码乘法是否会溢出</strong></p><ul><li><p>方法一：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/tmult_check.c style=color:lightslategrey;font-size:.8em>tmult_check.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>tmult_ok</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
  </span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>!</span><span class=n>x</span> <span class=o>||</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>/</span> <span class=n>x</span> <span class=o>==</span> <span class=n>y</span><span class=p>;</span>
  </span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>证明：</p><p>当 $x = 0$ 时，显然乘法不会溢出。</p><p>当 $x \ne 0$ 时，</p><ol><li>$x \cdot y$ 可以用 $2w$ 位的补码数表示，设其高 $w$ 位的补码数为 $v$，低 $w$ 位的无符号数为 $u$，则</li></ol><p>$$x \cdot y = v2^w + u$$</p><p>设补码乘法的结果为 $p$，则 $u = p + p_{w-1}2^w$，得</p><p>$$x \cdot y = v2^w + p + p_{w-1}2^w = p + t2^w$$</p><p>其中 $t = v + p_{w-1}$。</p><ul><li>当 $t = 0$ 时，$x \cdot y = p$，乘法不会溢出</li><li>当 $t \ne 0$ 时，$x \cdot y \ne p$，乘法溢出</li></ul><p>故乘法不会溢出的充要条件为 $t = 0$。</p><ol start=2><li>根据整数除法，设 $p$ 除以 $x$ 的商为 $q$，余数为 $r$，则 $p = x \cdot q + r$，且 $\mid r \mid &lt; \mid x \mid$，则</li></ol><p>$$x \cdot y = p + t2^w = x \cdot q + r + t2^w$$</p><ul><li>若 $q = y$，则 $r + t2^w = 0$，由于 $\mid r \mid &lt; \mid x \mid \le 2^{w-1}$，此时必有 $t = 0$ 且 $r = 0$</li><li>若 $t = 0$，则 $y - q = r / x$，由于 $\mid r \mid &lt; \mid x \mid$，此时必有 $y = q$</li></ul><p>故 $t = 0$ 的充要条件为 $q = y$。</p><p>综合 1、2 得，乘法不会溢出的充要条件为 $q = y$。</p></li><li><p>方法二：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/tmult_check.c style=color:lightslategrey;font-size:.8em>tmult_check.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>tmult_ok1</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
  </span></span><span class=line><span class=cl>    <span class=kt>int64_t</span> <span class=n>pll</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int64_t</span><span class=p>)</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span><span class=p>;</span>
  </span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>pll</span> <span class=o>==</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>pll</span><span class=p>;</span>
  </span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure></li></ul><h3 id=236-乘以常数>2.3.6 乘以常数</h3><p><strong>原理</strong>：与 2 的幂相乘的无符号乘法</p><p>对于无符号数值 $x$、$k$ 的 C 变量 <code>x</code> 和 <code>y</code>，且 $0 \le k &lt; w$，C 表达式 <code>x &lt;&lt; k</code> 产生数值 $x *_w^u 2^k$。</p><p><strong>原理</strong>：与 2 的幂相乘的补码乘法</p><p>对于补码数值 $x$、无符号数值 $k$ 的 C 变量 <code>x</code> 和 <code>k</code>，且 $0 \le k &lt; w$，C 表达式 <code>x &lt;&lt; k</code> 产生数值 $x *_w^t 2^k$。</p><p>无论是无符号还是补码运算，乘以 2 的幂都可能会溢出，即使溢出时其结果也与移位效果相同。</p><p>整数乘法的开销比移位和加法大得多，许多 C 编译器试图以移位和加减法的组合，来消除许多整数乘以常数的情况。例如 <code>x * 14</code>，$14 = 2^3 + 2^2 + 2^1$，编译器可以将乘法重写为 <code>(x &lt;&lt; 3) + (x &lt;&lt; 2) + (x &lt;&lt; 1)</code>，这样将乘法替换为三个移位和两个加法。无论 <code>x</code> 是无符号还是补码，甚至乘法会导致溢出时，两个计算都会得到一样的结果。还可以利用 $14 = 2^4 - 2^1$，乘法重写为 <code>(x &lt;&lt; 4) - (x &lt;&lt; 1)</code>，这时只需要两个移位和一个减法。</p><p>对于某个常数 $K$ 的表达式 <code>x * K</code>，编译器会将 $K$ 的二进制表示表达为一组 0 和 1 交替的序列。考虑一组从 $n$ 位到 $m$ 位的连续的 1（$n \ge m$），可以用两种不同的形式来计算这些位对乘积的作用：</p><ul><li><p>形式 A：<code>(x &lt;&lt; n) + (x &lt;&lt; (n - 1)) + ... + (x &lt;&lt; m)</code></p></li><li><p>形式 B：<code>(x &lt;&lt; (n + 1)) - (x &lt;&lt; m)</code></p></li></ul><p>选择用移位和加减法组合，还是乘法指令，取决于这些指令的相对速度。大多数编译器只在需要少量移位和加减法就足够时才使用这种优化。</p><h3 id=237-除以-2-的幂>2.3.7 除以 2 的幂</h3><p>整数除法总是舍入到零。</p><p><strong>原理</strong>：除以 2 的幂的无符号除法</p><p>对于无符号数值 $x$、$k$ 的 C 变量 <code>x</code> 和 <code>k</code>，且 $0 \le k &lt; w$，C 表达式 <code>x >> k</code> 产生数值 $\lfloor x/2^k \rfloor$。</p><p><strong>原理</strong>：除以 2 的幂的补码除法，向下舍入</p><p>对于补码数值 $x$、无符号数值 $k$ 的 C 变量 <code>x</code> 和 <code>k</code>，且 $0 \le k &lt; w$，当执行算数右移时 C 表达式 <code>x >> k</code> 产生数值 $\lfloor x/2^k \rfloor$。</p><p><strong>推导</strong>：</p><p>设 $x$ 为位模式 $[x_{w-1}, x_{w-2}, &mldr;, x_0]$ 表示的补码整数，$0 \le k &lt; w$，$x&rsquo;$ 为高 $w - k$ 位 $[x_{w-1}, x_{w-2}, &mldr;, x_k]$ 表示的补码数，$x&rsquo;&rsquo;$ 为低 $k$ 位表示的无符号数，显然 $x = 2^k x&rsquo; + x&rsquo;&rsquo;$，而 $0 \le x&rsquo;&rsquo; &lt; 2^k$，则 $x&rsquo; = \lfloor x / 2^k \rfloor$。而算数右移后位向量为</p><p>$$[x_{w-1}, &mldr;, x_{w-1}, x_{w-1}, x_{w-2}, &mldr;, x_k]$$</p><p>刚好是 $[x_{w-1}, x_{w-2}, &mldr;, x_k]$ 从 $w-k$ 位符号扩展到 $w$ 位，因此位移后的位向量即为 $\lfloor x / 2^k \rfloor$ 的补码表示。</p><p><strong>原理</strong>：除以 2 的幂的补码除法，向上舍入</p><p>对于补码数值 $x$、无符号数值 $k$ 的 C 变量 <code>x</code> 和 <code>k</code>，且 $0 \le k &lt; w$，当执行算数右移时 C 表达式 <code>(x + (1 &lt;&lt; k) - 1) >> k</code> 产生数值 $\lceil x/2^k \rceil$。</p><p><strong>推导</strong>：</p><p>设 $x = qy + r$，其中 $0 \le r &lt; y$，则 $\lfloor (x + y - 1) / y \rfloor = \lfloor (qy + r + y - 1) / y \rfloor = q + \lfloor (r + y - 1) / y \rfloor$。当 $x$ 能被 $y$ 整除时，$r = 0$，后面一项为 $0$，结果为 $q$，当不能整除时，$0 &lt; r &lt; y$，后面一项为 $1$，结果为 $q + 1$。综上得 $\lfloor (x + y - 1) / y \rfloor = \lceil y / x \rceil$。</p><p>C 表达式 <code>x + (1 &lt;&lt; k) - 1</code> 得到数值 $x + 2^k - 1$，再右移 $k$ 位，即除以 $2^k$，得 $\lceil x / 2^k \rceil$。</p><p>以上分析表明，对于使用算数右移的补码机器，C 表达式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>?</span> <span class=n>x</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>k</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>:</span> <span class=n>x</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>k</span>
</span></span></code></pre></div><p>将会计算数值 $x/2^k$。</p><h3 id=238-关于整数运算的最后思考>2.3.8 关于整数运算的最后思考</h3><p>补码使用了与无符号运算相同的位级实现，包括加法、减法、乘法甚至除法。</p><h2 id=24-浮点数>2.4 浮点数</h2><h3 id=242-ieee-浮点表示>2.4.2 IEEE 浮点表示</h3><p>IEEE 浮点标准用 $V = (-1)^s \times M \times 2^E$ 的形式来表示一个数。</p><p>浮点数位表示划分为三个字段：</p><ul><li><p>一个单独的符号位 s 直接编码符号 $s$</p></li><li><p>$k$ 位阶码字段 exp = $e_{k - 1}&mldr; e_1 e_0$ 编码阶码 $E$</p></li><li><p>$n$ 位小数字段 frac = $f_{n - 1}&mldr; f_1 f_0$ 编码尾数 $M$</p></li></ul><p>单精度浮点格式中，s、exp、frac 字段分别为 1 位、k = 8 位和 n = 23 位，双精度浮点格式中分别为 1 位、k = 11 位 和 n = 52 位。</p><p>根据 exp 的值，被编码的值可以分为三种情况。</p><p><strong>情况 1:规格化的值</strong></p><p>当 exp 的位模式既不全为 0 也不全为 1 时，浮点数为规格化的值。</p><p>阶码的值为 $E = e - Bias$，其中 $e$ 为无符号数，位表示为 $e_{k - 1}&mldr; e_1 e_0$，偏置值 $Bias = 2^{k - 1} - 1$（单精度是 127，双精度为 1023）。由此产生的指数取值范围，对于单精度为 -126 ~ +127，双精度为 -1022 ~ +1023。</p><p>小数字段 frac 描述小数值 $f$，其二进制表示为 $0.f_{n - 1}&mldr; f_1 f_0$，尾数值为 $M = 1 + f$。$M$ 可以看作二进制表示为 $1.f_{n - 1}&mldr; f_1 f_0$ 的数字，其开头的 1 是隐含的，这样可以获得额外的一位精度。</p><p><strong>情况 2:非规格化的值</strong></p><p>当阶码全为 0 时，浮点数表示非规格化的值。</p><p>此时阶码的值为 $E = 1 - Bias = 2 - 2^{k - 1}$，单精度即为 -126，双精度即为 -1022，与规格化值的最小阶码相同。尾数的值为 $M = f$，即不包含隐含位。这种设置可以让规格化值与规格化数值之间平滑过渡。</p><p>功能 1：表示 0。规格化数中尾数总是 $M \ge 1$，无法表示 0，但是非规格化可以表示 0：</p><ul><li><p>+0.0：所有位都为 0</p></li><li><p>-0.0：符号位为 1，其它位全为 0</p></li></ul><p>功能 2：表示非常接近 0 的数。非规格化数是均匀接近于 0 的（渐进式下溢，gradual underflow），而规格化数绝对值越小分布越稠密。</p><p><strong>情况 3:特殊值</strong></p><p>当阶码全为 1 时，浮点数为特殊值。</p><p>当小数字段全为 0 时，值为无穷，且 $s = 0$ 时为 $+\infty$，$s = 1$ 时为 $-\infty$，可以表示溢出的结果。</p><p>当小数字段不为 0 时，值为 NaN（Not a Number），例如 $\sqrt{-1}$ 或 $\infty - \infty$ 的结果。也可用来表示未初始化的数据。</p><h3 id=243-数字示例>2.4.3 数字示例</h3><table><thead><tr><th>描述</th><th>位表示</th><th>值</th></tr></thead><tbody><tr><td>0</td><td>0 00000000 00000000000000000000000</td><td>$0$</td></tr><tr><td>最小非规格化数</td><td>0 00000000 00000000000000000000001</td><td>$2^{-23} \cdot 2^{-126}$</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td></tr><tr><td>最大非规格化数</td><td>0 00000000 11111111111111111111111</td><td>$(1 - 2^{-23}) \cdot 2^{-126}$</td></tr><tr><td>最小规格化数</td><td>0 00000001 00000000000000000000000</td><td>$2^{-126}$</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td></tr><tr><td>最大规格化数</td><td>0 11111110 11111111111111111111111</td><td>$(2 - 2^{-23}) \cdot 2^{127}$</td></tr><tr><td>无穷大</td><td>0 11111111 00000000000000000000000</td><td>$\infty$</td></tr></tbody></table><p>C 语言中 <code>float.h</code> 中定义了一些浮点数的值。</p><p>Java 中 <code>Float</code> 类定义了一些单精度浮点数的值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>class</span> <span class=nc>Float</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Number</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Comparable</span><span class=o>&lt;</span><span class=n>Float</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * A constant holding the positive infinity of type
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code float}. It is equal to the value returned by
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code Float.intBitsToFloat(0x7f800000)}.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>POSITIVE_INFINITY</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>.</span><span class=na>0f</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0f</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * A constant holding the negative infinity of type
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code float}. It is equal to the value returned by
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code Float.intBitsToFloat(0xff800000)}.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>NEGATIVE_INFINITY</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>.</span><span class=na>0f</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0f</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * A constant holding a Not-a-Number (NaN) value of type
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code float}.  It is equivalent to the value returned by
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code Float.intBitsToFloat(0x7fc00000)}.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>NaN</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0f</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0f</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * A constant holding the largest positive finite value of type
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code float}, (2-2&lt;sup&gt;-23&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;127&lt;/sup&gt;.
</span></span></span><span class=line><span class=cl><span class=cm>     * It is equal to the hexadecimal floating-point literal
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code 0x1.fffffeP+127f} and also equal to
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code Float.intBitsToFloat(0x7f7fffff)}.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>MAX_VALUE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0x1</span><span class=p>.</span><span class=na>fffffeP</span><span class=o>+</span><span class=n>127f</span><span class=p>;</span><span class=w> </span><span class=c1>// 3.4028235e+38f</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * A constant holding the smallest positive normal value of type
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code float}, 2&lt;sup&gt;-126&lt;/sup&gt;.  It is equal to the
</span></span></span><span class=line><span class=cl><span class=cm>     * hexadecimal floating-point literal {@code 0x1.0p-126f} and also
</span></span></span><span class=line><span class=cl><span class=cm>     * equal to {@code Float.intBitsToFloat(0x00800000)}.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @since 1.6
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>MIN_NORMAL</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0x1</span><span class=p>.</span><span class=na>0p</span><span class=o>-</span><span class=n>126f</span><span class=p>;</span><span class=w> </span><span class=c1>// 1.17549435E-38f</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * A constant holding the smallest positive nonzero value of type
</span></span></span><span class=line><span class=cl><span class=cm>     * {@code float}, 2&lt;sup&gt;-149&lt;/sup&gt;. It is equal to the
</span></span></span><span class=line><span class=cl><span class=cm>     * hexadecimal floating-point literal {@code 0x0.000002P-126f}
</span></span></span><span class=line><span class=cl><span class=cm>     * and also equal to {@code Float.intBitsToFloat(0x1)}.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>MIN_VALUE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0x0</span><span class=p>.</span><span class=na>000002P</span><span class=o>-</span><span class=n>126f</span><span class=p>;</span><span class=w> </span><span class=c1>// 1.4e-45f</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>上面表格中的值，如果把浮点数的位表示解释为无符号整数，它们就是按升序排列的，就像它们表示的浮点数一样，以便使用整数排序函数进行排序。如果符号位为 1，就是降序排列的。</p><h3 id=244-舍入>2.4.4 舍入</h3><p>IEEE 浮点数规定了四种舍入方式：</p><ol><li>Round-to-even 向偶数舍入（向最接近的值舍入）</li></ol><p>是默认方式，将结果舍入为最接近的值，如果两个数一样接近时，则取最低有效数字为偶数的值。这样的好处是避免统计偏差。例如如果总是向上舍入，则平均值总是比实际高一些。</p><ol start=2><li><p>Round-toward-zero 向零舍入</p></li><li><p>Round-down 向下舍入</p></li><li><p>Round-up 向上舍入</p></li></ol><h3 id=245-浮点运算>2.4.5 浮点运算</h3><p>浮点加法是可交换的，但不可结合，例如 <code>(3.14 + 1e10) - 1e10</code> 的结果为 <code>0.0</code>，但 <code>3.14 + (1e10 - 1e10)</code> 的结果为 <code>3.14</code>，由于舍入而丢失了精度。编译器就无法利用结合性进行优化。</p><p>浮点加法具有单调性：如果 $a \ge b$，那么对于任何 $a$、$b$ 和 $x$ 的值，除 $NaN$ 外，都有 $x + a \ge x + b$。而无符号或补码加法则不具有。</p><p>浮点乘法也是可交换但不可结合的，例如 <code>(1e20 * 1e20) * 1e-20</code> 结果为 <code>inf</code>，<code>1e20 * (1e20 * 1e-20)</code> 结果为 <code>1e20</code>。浮点乘法在加法上不具备分配性，例如 <code>1e20 * (1e20 - 1e20)</code> 的结果为 <code>0.0</code>，<code>1e20 * 1e20 - 1e20 * 1e20</code> 结果为 <code>nan</code>。</p><h2 id=家庭作业>家庭作业</h2><h3 id=258>2.58</h3><p>判断是否为小端机器：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/is_little_endian.c style=color:lightslategrey;font-size:.8em>is_little_endian.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>is_little_endian</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=262>2.62</h3><p>判断是否为算数右移：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/is_shifts_are_arithmetic.c style=color:lightslategrey;font-size:.8em>is_shifts_are_arithmetic.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=kt>size_t</span> <span class=n>W</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>is_shifts_are_arithmetic</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>W</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=263>2.63</h3><p>用算数右移模拟逻辑右移、用逻辑右移模拟算数右移：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/right_shifts.c style=color:lightslategrey;font-size:.8em>right_shifts.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=kt>size_t</span> <span class=n>W</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=nf>srl</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>k</span> <span class=o>&amp;&amp;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Perform shift arithmetically */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>xsra</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>mask</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>W</span> <span class=o>-</span> <span class=n>k</span><span class=p>))</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>xsra</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sra</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>k</span> <span class=o>&amp;&amp;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Perform shift logically */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>xsrl</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>sign</span> <span class=o>=</span> <span class=p>((</span><span class=kt>unsigned</span><span class=p>)</span> <span class=n>x</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>W</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>mask</span> <span class=o>=</span> <span class=o>~</span><span class=p>((</span><span class=n>sign</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>W</span> <span class=o>-</span> <span class=n>k</span><span class=p>))</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>xsrl</span> <span class=o>|</span> <span class=n>mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=265>2.65</h3><p>判断无符号整数二进制形式中是否有奇数个 1：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/odd_ones.c style=color:lightslategrey;font-size:.8em>odd_ones.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Return 1 when x contains an odd number of 1s; 0 otherwise.
</span></span></span><span class=line><span class=cl><span class=cm> * Assume w=32 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>odd_ones</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=o>==</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>^=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>^=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>^=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>^=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>^=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>让所有二进制位做异或操作，即得到结果。</p><h3 id=266>2.66</h3><p>找到无符号整数二进制形式中最高位的 1：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/leftmost_one.c style=color:lightslategrey;font-size:.8em>leftmost_one.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Generate mask indicating leftmost 1 in x.  Assume w=32.
</span></span></span><span class=line><span class=cl><span class=cm> * For example, 0xFF00 -&gt; 0x8000, and 0x6600 --&gt; 0x4000.
</span></span></span><span class=line><span class=cl><span class=cm> * If x = 0, then return 0.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>leftmost_one</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=o>==</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>|=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>|=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>|=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>|=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>|=</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>^</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=267>2.67</h3><p>判断 <code>int</code> 类型是否为 32 位，可以在 16 位及以上的机器上运行：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/int_size_is_32.c style=color:lightslategrey;font-size:.8em>int_size_is_32.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>int_size_is_32</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>set_msb</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>15</span> <span class=o>&lt;&lt;</span> <span class=mi>15</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>beyond_msb</span> <span class=o>=</span> <span class=n>set_msb</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>set_msb</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>beyond_msb</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=268>2.68</h3><p>生成低 n 位为 1 的掩码：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/lower_one_mask.c style=color:lightslategrey;font-size:.8em>lower_one_mask.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=kt>size_t</span> <span class=n>W</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Mask with least signficant n bits set to 1
</span></span></span><span class=line><span class=cl><span class=cm> * Examples: n = 6 --&gt; 0x3F, n = 17 --&gt; 0x1FFFF
</span></span></span><span class=line><span class=cl><span class=cm> * Assume 1 &lt;= n &lt;= w
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>lower_one_mask</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;=</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=n>W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=269>2.69</h3><p>实现循环左移：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/rotate_left.c style=color:lightslategrey;font-size:.8em>rotate_left.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=kt>size_t</span> <span class=n>W</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Do rotating left shift.  Assume 0 &lt;= n &lt; w
</span></span></span><span class=line><span class=cl><span class=cm> * Examples when x = 0x12345678 and w = 32:
</span></span></span><span class=line><span class=cl><span class=cm> *    n=4 -&gt; 0x23456781, n=20 -&gt; 0x67812345
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=nf>rotate_left</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>n</span> <span class=o>&lt;</span> <span class=n>W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>W</span> <span class=o>-</span> <span class=n>n</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=270>2.70</h3><p>判断 x 能否用 n 位补码表示：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/fits_bits.c style=color:lightslategrey;font-size:.8em>fits_bits.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=kt>size_t</span> <span class=n>W</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Return 1 when x can be represented as an n-bit, 2&#39;s-complement
</span></span></span><span class=line><span class=cl><span class=cm> * number; 0 otherwise
</span></span></span><span class=line><span class=cl><span class=cm> * Assume 1 &lt;= n &lt;= w
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fits_bits</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;=</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=n>W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>mask</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>W</span> <span class=o>-</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>==</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=273>2.73</h3><p>补码加法，溢出时返回最值：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/saturating_add.c style=color:lightslategrey;font-size:.8em>saturating_add.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Addition that saturates to TMin or TMax */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>saturating_add</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>of</span> <span class=o>=</span> <span class=o>!</span><span class=p>(</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>y</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>s</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>of</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>s</span> <span class=o>=</span> <span class=n>INT_MAX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>uf</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>y</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>s</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>uf</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>s</span> <span class=o>=</span> <span class=n>INT_MIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=274>2.74</h3><p>判断补码减法是否溢出：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/tsub_ok.c style=color:lightslategrey;font-size:.8em>tsub_ok.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Determine whether arguments can be subtracted without overflow */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>tsub_ok</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>of</span> <span class=o>=</span> <span class=o>!</span><span class=p>(</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>y</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>s</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>uf</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>y</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>s</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>!</span><span class=n>of</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>uf</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=275>2.75</h3><p>已知补码乘法高 $w$ 位，求无符号整数乘法高 $w$ 位。</p><p>在补码乘法与无符号乘法的位级等价性推导中，</p><p>$$x&rsquo; \cdot y&rsquo; = (x + x_{w-1}2^w)(y + y_{w-1}2^w) = x \cdot y + (xy_{w-1} + yx_{w-1})2^w + 2^{2w}$$</p><p>两边同时除以 $2^w$ 即可得到乘积的高 $w$ 位。</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/unsigned_high_prod.c style=color:lightslategrey;font-size:.8em>unsigned_high_prod.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=kt>size_t</span> <span class=n>W</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>signed_high_prod</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>int64_t</span><span class=p>)</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>&gt;&gt;</span> <span class=n>W</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=nf>unsigned_high_prod</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>x</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>shp</span> <span class=o>=</span> <span class=nf>signed_high_prod</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>shp</span> <span class=o>+</span> <span class=n>x</span> <span class=o>*</span> <span class=p>(</span><span class=n>y</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>W</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span> <span class=o>+</span> <span class=n>y</span> <span class=o>*</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>W</span> <span class=o>-</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=nf>uhp</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>x</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>&gt;&gt;</span> <span class=n>W</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=276>2.76</h3><p>实现 <code>calloc</code> 函数：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/calloc.c style=color:lightslategrey;font-size:.8em>calloc.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>calloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>nmemb</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>nmemb</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=n>nmemb</span> <span class=o>*</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>/</span> <span class=n>nmemb</span> <span class=o>!=</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>memset</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=278>2.78</h3><p>用移位实现除以 2 的幂算法，由于除法是向零取整的，当 $x &lt; 0$ 时需要加一个偏移量：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/divide_power2.c style=color:lightslategrey;font-size:.8em>divide_power2.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=kt>size_t</span> <span class=n>W</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Divide by power of 2. Assume 0 &lt;= k &lt; w-1 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>divide_power2</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>k</span> <span class=o>&amp;&amp;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>W</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bias</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>bias</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>k</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>bias</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=279>2.79</h3><p>计算 $3x/4$，其中 $3x$ 可能溢出：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/mul3div4.c style=color:lightslategrey;font-size:.8em>mul3div4.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>mul3div4</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>+=</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bias</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>bias</span> <span class=o>=</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>bias</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=280>2.80</h3><p>计算 $3x/4$，其中 $3x$ 不允许溢出，此时可把 $x$ 分为高 $w-2$ 位和低 $2$ 位两部分计算，其中高位无需考虑舍入，只有低位需要加入偏移量：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/threefourths.c style=color:lightslategrey;font-size:.8em>threefourths.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>threefourths</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>high</span> <span class=o>=</span> <span class=n>x</span> <span class=o>&amp;</span> <span class=o>~</span><span class=mi>3</span><span class=p>,</span> <span class=n>low</span> <span class=o>=</span> <span class=n>x</span> <span class=o>&amp;</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>high</span> <span class=o>=</span> <span class=p>(</span><span class=n>high</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>high</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>low</span> <span class=o>+=</span> <span class=n>low</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bias</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>x</span> <span class=o>&amp;</span> <span class=n>INT_MIN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>bias</span> <span class=o>=</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>high</span> <span class=o>+</span> <span class=p>((</span><span class=n>low</span> <span class=o>+</span> <span class=n>bias</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=283>2.83</h3><p>A. 设 $x$ 的二进制表示为 $0.yyyy&mldr;$，其中 $y$ 是一个 $k$ 位序列，两边同时左移 $k$ 位得</p><p>$$x &#171; k = y.yyy&mldr;$$</p><p>$$x \cdot 2^k = y + x$$</p><p>$$x = \frac{y}{2^k-1}$$</p><h3 id=284>2.84</h3><p>比较浮点数大小：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/float_le.c style=color:lightslategrey;font-size:.8em>float_le.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>unsigned</span> <span class=nf>f2u</span><span class=p>(</span><span class=kt>float</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=p>(</span><span class=kt>unsigned</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>float_le</span><span class=p>(</span><span class=kt>float</span> <span class=n>x</span><span class=p>,</span> <span class=kt>float</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=o>==</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>ux</span> <span class=o>=</span> <span class=nf>f2u</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>uy</span> <span class=o>=</span> <span class=nf>f2u</span><span class=p>(</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Get the sign bits */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>sx</span> <span class=o>=</span> <span class=n>ux</span> <span class=o>&gt;&gt;</span> <span class=mi>31</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>sy</span> <span class=o>=</span> <span class=n>uy</span> <span class=o>&gt;&gt;</span> <span class=mi>31</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Give an expression using only ux, uy, sx, and sy */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>ux</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>uy</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=p>(</span><span class=n>sx</span> <span class=o>^</span> <span class=n>sy</span> <span class=o>?</span> <span class=nl>sx</span> <span class=p>:</span> <span class=p>(</span><span class=n>sx</span> <span class=o>?</span> <span class=n>ux</span> <span class=o>&gt;=</span> <span class=nl>uy</span> <span class=p>:</span> <span class=n>ux</span> <span class=o>&lt;=</span> <span class=n>uy</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=290>2.90</h3><p>求浮点数 $2^x$：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/fpwr2.c style=color:lightslategrey;font-size:.8em>fpwr2.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>unsigned</span> <span class=nf>f2u</span><span class=p>(</span><span class=kt>float</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=p>(</span><span class=kt>unsigned</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>u2f</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>u</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=p>(</span><span class=kt>float</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>fpwr2</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Result exponent and fraction */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>exp</span><span class=p>,</span> <span class=n>frac</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=o>-</span><span class=mi>149</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Too small.  Return 0.0 */</span>
</span></span><span class=line><span class=cl>        <span class=n>exp</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>frac</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=o>-</span><span class=mi>126</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Denormalized result */</span>
</span></span><span class=line><span class=cl>        <span class=n>exp</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>frac</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>149</span> <span class=o>+</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>128</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Normalized result. */</span>
</span></span><span class=line><span class=cl>        <span class=n>exp</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>127</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>frac</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Too big.  Return +oo */</span>
</span></span><span class=line><span class=cl>        <span class=n>exp</span> <span class=o>=</span> <span class=mi>255</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>frac</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Pack exp and frac into 32 bits */</span>
</span></span><span class=line><span class=cl>    <span class=n>u</span> <span class=o>=</span> <span class=n>exp</span> <span class=o>&lt;&lt;</span> <span class=mi>23</span> <span class=o>|</span> <span class=n>frac</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Return as float */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>u2f</span><span class=p>(</span><span class=n>u</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=292>2.92</h3><p>求浮点数相反数：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/float_negate.c style=color:lightslategrey;font-size:.8em>float_negate.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=n>float_bits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Compute -f.  If f is NaN, then return f. */</span>
</span></span><span class=line><span class=cl><span class=n>float_bits</span> <span class=nf>float_negate</span><span class=p>(</span><span class=n>float_bits</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>sign</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x80000000</span><span class=p>,</span> <span class=n>exp</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x7f800000</span><span class=p>,</span> <span class=n>frac</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x007fffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>exp</span> <span class=o>==</span> <span class=mh>0x7f800000</span> <span class=o>&amp;&amp;</span> <span class=n>frac</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>sign</span> <span class=o>^=</span> <span class=mh>0x80000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sign</span> <span class=o>|</span> <span class=n>exp</span> <span class=o>|</span> <span class=n>frac</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=293>2.93</h3><p>求浮点数绝对值：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/float_absval.c style=color:lightslategrey;font-size:.8em>float_absval.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=n>float_bits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Compute |f|.  If f is NaN, then return f. */</span>
</span></span><span class=line><span class=cl><span class=n>float_bits</span> <span class=nf>float_absval</span><span class=p>(</span><span class=n>float_bits</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>sign</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x80000000</span><span class=p>,</span> <span class=n>exp</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x7f800000</span><span class=p>,</span> <span class=n>frac</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x007fffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sign</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>exp</span> <span class=o>==</span> <span class=mh>0x7f800000</span> <span class=o>&amp;&amp;</span> <span class=n>frac</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>sign</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sign</span> <span class=o>|</span> <span class=n>exp</span> <span class=o>|</span> <span class=n>frac</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=294>2.94</h3><p>求浮点数 $2x$：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/float_twice.c style=color:lightslategrey;font-size:.8em>float_twice.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=n>float_bits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Compute 2*f.  If f is NaN, then return f. */</span>
</span></span><span class=line><span class=cl><span class=n>float_bits</span> <span class=nf>float_twice</span><span class=p>(</span><span class=n>float_bits</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>f</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=p>(</span><span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x7f800000</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x7f800000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>sign</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x80000000</span><span class=p>,</span> <span class=n>exp</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x7f800000</span><span class=p>,</span> <span class=n>frac</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x007fffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>exp</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>sign</span> <span class=o>|</span> <span class=n>f</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>exp</span> <span class=o>+=</span> <span class=mh>0x00800000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>exp</span> <span class=o>==</span> <span class=mh>0x7f800000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>frac</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sign</span> <span class=o>|</span> <span class=n>exp</span> <span class=o>|</span> <span class=n>frac</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>IEEE 浮点数的设计很精妙，当浮点数为非规格化时，直接将除符号位外整体左移一位即可。</p><h3 id=295>2.95</h3><p>求浮点数 $0.5x$：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/float_half.c style=color:lightslategrey;font-size:.8em>float_half.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=n>float_bits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Compute 0.5*f.  If f is NaN, then return f. */</span>
</span></span><span class=line><span class=cl><span class=n>float_bits</span> <span class=nf>float_half</span><span class=p>(</span><span class=n>float_bits</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>f</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=p>(</span><span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x7f800000</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x7f800000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>sign</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x80000000</span><span class=p>,</span> <span class=n>exp</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x7f800000</span><span class=p>,</span> <span class=n>frac</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x007fffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>exp</span> <span class=o>&amp;</span> <span class=mh>0x7f000000</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span> <span class=o>&amp;=</span> <span class=mh>0x7fffffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>f</span> <span class=o>&amp;</span> <span class=mi>3</span><span class=p>)</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>sign</span> <span class=o>|</span> <span class=n>f</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>exp</span> <span class=o>-=</span> <span class=mh>0x00800000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sign</span> <span class=o>|</span> <span class=n>exp</span> <span class=o>|</span> <span class=n>frac</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>比求 $2x$ 要复杂一些，因为当尾数右移时要考虑舍入的问题，如果最后两位为 <code>11</code>，则需要添加一个偏移量以向偶数舍入。</p><h3 id=296>2.96</h3><p><code>float</code> 转换为 <code>int</code>：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/float_f2i.c style=color:lightslategrey;font-size:.8em>float_f2i.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=n>float_bits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Compute (int) f.
</span></span></span><span class=line><span class=cl><span class=cm> * If convertion causes overflow or f is NaN, return 0x80000000
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>float_f2i</span><span class=p>(</span><span class=n>float_bits</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>exp</span> <span class=o>=</span> <span class=p>((</span><span class=n>f</span> <span class=o>&gt;&gt;</span> <span class=mi>23</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>)</span> <span class=o>-</span> <span class=mi>127</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>exp</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>exp</span> <span class=o>&gt;</span> <span class=mi>30</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mh>0x80000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sign</span> <span class=o>=</span> <span class=n>f</span> <span class=o>&gt;&gt;</span> <span class=mi>31</span><span class=p>,</span> <span class=n>frac</span> <span class=o>=</span> <span class=p>(</span><span class=n>f</span> <span class=o>&amp;</span> <span class=mh>0x007fffff</span><span class=p>)</span> <span class=o>|</span> <span class=mh>0x00800000</span><span class=p>,</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>exp</span> <span class=o>&lt;</span> <span class=mi>23</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>value</span> <span class=o>=</span> <span class=n>frac</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=mi>23</span> <span class=o>-</span> <span class=n>exp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>exp</span> <span class=o>&gt;</span> <span class=mi>23</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>value</span> <span class=o>=</span> <span class=n>frac</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>exp</span> <span class=o>-</span> <span class=mi>23</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sign</span> <span class=o>?</span> <span class=o>-</span><span class=nl>value</span> <span class=p>:</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h3 id=297>2.97</h3><p><code>int</code> 转换为 <code>float</code>：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/csapp-representing-and-manipulating-information/float_i2f.c style=color:lightslategrey;font-size:.8em>float_i2f.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=n>float_bits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Compute (float) i */</span>
</span></span><span class=line><span class=cl><span class=n>float_bits</span> <span class=nf>float_i2f</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>sign</span> <span class=o>=</span> <span class=n>i</span> <span class=o>&amp;</span> <span class=mh>0x80000000</span><span class=p>,</span> <span class=n>frac</span> <span class=o>=</span> <span class=n>sign</span> <span class=o>?</span> <span class=o>-</span><span class=nl>i</span> <span class=p>:</span> <span class=n>i</span><span class=p>,</span> <span class=n>exp</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=n>u</span> <span class=o>=</span> <span class=n>frac</span><span class=p>;</span> <span class=n>u</span><span class=p>;</span> <span class=o>++</span><span class=n>exp</span><span class=p>)</span> <span class=n>u</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>exp</span> <span class=o>&lt;</span> <span class=mi>23</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>frac</span> <span class=o>&lt;&lt;=</span> <span class=mi>23</span> <span class=o>-</span> <span class=n>exp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>exp</span> <span class=o>&gt;</span> <span class=mi>23</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=n>w</span> <span class=o>=</span> <span class=n>exp</span> <span class=o>-</span> <span class=mi>23</span><span class=p>,</span> <span class=n>mask</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=mi>32</span> <span class=o>-</span> <span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=n>shifts</span> <span class=o>=</span> <span class=n>frac</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=p>,</span> <span class=n>mid</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>w</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=n>bias</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>shifts</span> <span class=o>&gt;</span> <span class=n>mid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>bias</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>w</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>shifts</span> <span class=o>==</span> <span class=n>mid</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>frac</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>w</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=n>bias</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>w</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>frac</span> <span class=o>=</span> <span class=p>(</span><span class=n>frac</span> <span class=o>+</span> <span class=n>bias</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>exp</span> <span class=o>-</span> <span class=mi>23</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>exp</span> <span class=o>=</span> <span class=p>(</span><span class=n>exp</span> <span class=o>+</span> <span class=mi>127</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>23</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>frac</span> <span class=o>&amp;=</span> <span class=mh>0x007fffff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sign</span> <span class=o>|</span> <span class=n>exp</span> <span class=o>|</span> <span class=n>frac</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>比 <code>float</code> 转换为 <code>int</code> 复杂一些，因为要考虑舍入的问题。</p></article><section class="article labels"><a class=tag href=/tags/csapp/>CSAPP</a><a class=tag href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/prime-sieve-and-goldbach-s-conjecture/><span class="iconfont icon-article"></span>素数筛法和哥德巴赫猜想</a></p><p><a class=link href=/posts/csapp-a-tour-of-computer-systems/><span class="iconfont icon-article"></span>CSAPP 计算机系统漫游</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>