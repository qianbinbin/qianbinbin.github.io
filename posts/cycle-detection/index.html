<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>Floyd 判圈算法&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="Floyd 判圈算法"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">Floyd 判圈算法</h1><p class="article date">2017-12-01</p></section><article class="article markdown-body"><p>判断一个单链表中是否存在环，并找出环的入口：
<a href=https://leetcode.com/problems/linked-list-cycle-ii/ target=_blank rel="noopener noreferrer">https://leetcode.com/problems/linked-list-cycle-ii/</a></p><blockquote><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>Note: Do not modify the linked list.</p><p>Follow up:
Can you solve it without using extra space?</p></blockquote><p>不知道 LeetCode 难度评级的标准是什么，有的 hard 题看完题目就有思路，像这种 medium 题我琢磨半天也想不出空间复杂度为 $O(1)$ 的解法。后来了解到这一题已经有著名的解法了，即 Floyd 判圈算法，没错，就是求最短路径的弗洛伊德算法的那个 Floyd。</p><h2 id=哈希表法>哈希表法</h2><p>时间复杂度 $O(n)$，空间复杂度 $O(n)$。略。</p><h2 id=floyd-判圈算法>Floyd 判圈算法</h2><p>在一个环中，如果两人速度不等且保持不变，那么总有一个时刻两者会相遇。应用此技巧，让一个<code>slow</code>指针每次移动一个结点，<code>fast</code>指针每次移动两个结点，如果两者最终能相遇，则说明单链表中存在环，如果<code>fast</code>走到了表尾，则说明不存在。</p><p>如果要求环长也好办，当两者相遇时，让其中一人保持不动，另一人再移动一圈，再次相遇时移动的路程即为环长。</p><p>但如何求出环的入口呢？</p><p>现已知单链表中存在环，设头结点与环入口距离为 $a$，从环入口到相遇结点的距离为 $b$，环长度为 $r$，<code>slow</code>指针在相遇前已经在环中移动了 $n_1$ 圈，<code>fast</code>指针在相遇前已经在环中移动了 $n_2$ 圈，那么<code>slow</code>指针移动的总路程为
$$s_1 = a + n_1r + b$$</p><p><code>fast</code>指针移动的总路程为
$$s_2 = a + n_2r + b$$</p><p>由于<code>fast</code>移动速度为<code>slow</code>的两倍，路程也为两倍，则 $s_2 = 2s_1$，两式相减得
$$s_2 - s_1 = s_1 = (n_2 - n_1)r$$</p><p>这说明<code>slow</code>和<code>fast</code>指针移动路程都为环长的整数倍。</p><p>现增设一个指针<code>slow1</code>，让其从头结点开始，每次移动一个结点，与相遇结点处的<code>slow</code>指针同时出发。当<code>slow1</code>移动到环的入口，即距离为 $a$ 时，<code>slow</code>移动的距离为
$$s_1&rsquo; = s_1 + a$$</p><p><code>slow</code>指针也一定停留在环的入口，它可以看作先移动了距离 $a$，即环入口处，又绕环移动了若干圈。</p><p>这说明，当<code>slow</code>和<code>slow1</code>相遇时，相遇结点必定为环的入口。</p><p>时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><h2 id=实现源码>实现源码</h2><p><a href=https://github.com/qianbinbin/leetcode target=_blank rel="noopener noreferrer">https://github.com/qianbinbin/leetcode</a></p></article><section class="article labels"><a class=tag href=/tags/leetcode/>LeetCode</a><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/binary-tree-interative-traversal/><span class="iconfont icon-article"></span>二叉树非递归遍历算法的快速实现</a></p><p><a class=link href=/posts/single-number-ii/><span class="iconfont icon-article"></span>Single Number II</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>