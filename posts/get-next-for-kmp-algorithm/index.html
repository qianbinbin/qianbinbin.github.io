<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>KMP 算法中的 next 数组&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="KMP 算法中的 next 数组"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">KMP 算法中的 next 数组</h1><p class="article date">2021-03-18</p></section><article class="article markdown-body"><p>对于字符串匹配，即在字符串 s 中寻找 p 子串的位置，如果使用暴力匹配，则时间复杂度为 $O(mn)$。而 KMP 算法在字符串重复率较高时可以获得更好的性能，时间复杂度为 $O(m + n)$。</p><p>KMP 算法的关键在于 next 数组。它用来表示在某个位置查找时，如果 p 与 s 不匹配，则 p 应回退的位置。</p><p>例如（第一行 s，第二行 p）：</p><pre tabindex=0><code>...ababax...
   ababay...
</code></pre><p><code>x</code> 与 <code>y</code> 不匹配，则 s 指针无需移动，p 应从 p[3] 继续匹配，即：</p><pre tabindex=0><code>...ababax...
     ababay...
</code></pre><p>next 数组利用了匹配到某个位置时，s 失配字符前面的部分子串是已知的，与 p 不匹配字符前的子串相同（在本例中即为 <code>ababa</code>），于是可以直接移动 p 指针到下一个可能的位置，从而减少了暴力匹配中的冗余。</p><p>显然，next 数组只与 p 有关。</p><p>观察得知，移动 p 指针后，一部分子串重合。也就是说子串 <code>ababa</code> 有相同的前缀和后缀 <code>aba</code>，这为 next 数组的计算提供了根据。事实上，如果子串不存在公共前后缀，那么就该让 s 指针移动了。</p><p>而且，这个公共前后缀应为最长，否则会丢失可能的位置，例如不能这样匹配（取公共前后缀为 <code>a</code>）：</p><pre tabindex=0><code>...ababax...
       ababay...
</code></pre><h2 id=计算-next-数组>计算 next 数组</h2><p>首先明确 next 数组元素值的含义：</p><ul><li>next[i] = -1，表示应该让 s 指针移动到下一个位置，p 从头开始匹配。</li><li>next[i] >= 0，表示 p 应回退到 next[i] 位置，s 指针不变。</li></ul><p>next 数组的计算利用了类似动态规划的思想：在 next[0&mldr;i] 已知的情况下，求 next[i+1]。</p><pre tabindex=0><code>0 ... j ...... i i+1
----- ?  ----- ?
** **    ** **
</code></pre><p>设 j = next[i]，说明 p[0:i] 有公共前后缀 p[0:j] = p[i-j:i]，即 <code>-----</code> 部分。</p><p>注：p[i:j] 是 Python 切片语法，表示 p 在坐标范围 [i,j) 中的子串。</p><ul><li>若 p[j] = p[i]，则说明找到长度为 j+1 的公共前后缀 p[0:j+1] = p[i-j:i+1]，得 next[i+1] = j+1。</li><li>若 p[j] != p[i]，说明不存在长度为 j+1 的公共前后缀，但如果 next[j] 也存在的话，说明 p[0:j] 也存在公共前后缀，即 <code>**</code> 部分，而它必定也是 p[0:i] 的公共前后缀，此时递归地按照上面的流程查找即可。</li><li>若查找到最后，j = -1，则 next[i] = 0。</li></ul><p>其余只需设置初始条件 next[0] = -1。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=nf>get_next</span><span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>next</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>size</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>next</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>j</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>next</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>next</span><span class=p>[</span><span class=o>++</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=o>++</span><span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=优化>优化</h3><p>上面的算法存在优化的可能，例如：</p><pre tabindex=0><code>...abx...
   aba...
</code></pre><p>按照之前的算法，next[2] = 0，也就是从 p 头部继续匹配，但 p[2] = p[0] = <code>a</code>，而它必定与 s 中的 <code>x</code> 不匹配，应该为 next[2] = -1。</p><p>因此在上面的算法中，找到公共前后缀后，还要判断是否有 p[i+1] = p[j+1]，若有，则 next[i+1] 不再是 j+1，而是 next[j+1]：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=nf>get_next</span><span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>next</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>size</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>next</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>j</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>next</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>next</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>?</span> <span class=nl>j</span> <span class=p>:</span> <span class=n>next</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if (p[j + 1] == p[i + 1])
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//     next[++i] = next[++j];
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// else
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//     next[++i] = ++j;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意这一判断不能放在内层 while 循环，因为 j 的实际含义不是应回退的位置，而是 p[0:i+1] 的最长公共前后子串长度，这一结果需要在下次外层 while 循环中使用。</p><h2 id=参考资料>参考资料</h2><p><a href=https://www.cnblogs.com/tangzhengyue/p/4315393.html target=_blank rel="noopener noreferrer">KMP算法的Next数组详解 - 唐小喵 - 博客园</a></p></article><section class="article labels"><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a><a class=tag href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/macos-clean-dumb-dotfiles/><span class="iconfont icon-article"></span>macOS 清除 ._*、.DS_Store 隐藏垃圾文件</a></p><p><a class=link href=/posts/ostep-cpu-virtualization/><span class="iconfont icon-article"></span>OSTEP CPU 虚拟化</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>