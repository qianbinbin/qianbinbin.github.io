<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>Java 集合框架&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="Java 集合框架"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">Java 集合框架</h1><p class="article date">2019-04-17</p></section><article class="article markdown-body"><h2 id=collection>Collection</h2><p><img src=/images/java-collections-framework/collection.png alt></p><p>Collection 接口基本可分为三种，List、Set 和 Queue。这些接口有对应实现的抽象类，实体类只需要继承抽象类即可，免去不必要的重复编码。</p><p>为什么实体类继承了对应的抽象类，还要实现接口呢？例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>AbstractList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>implements</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>RandomAccess</span><span class=p>,</span><span class=w> </span><span class=n>Cloneable</span><span class=p>,</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>io</span><span class=p>.</span><span class=na>Serializable</span><span class=w>
</span></span></span></code></pre></div><p>事实上这就是个错误，Java 集合框架最初版的作者承认了：<a href=https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete target=_blank rel="noopener noreferrer">java - Why does LinkedHashSet<e> extend HashSet<e> and implement Set<e> - Stack Overflow</a></p><h3 id=list>List</h3><ul><li><p>ArrayList</p><p>数组实现。默认容量为 10，容量不够时，增加一半。</p></li><li><p>LinkedList</p><p>双向链表实现，同时实现了 Deque 接口。链式存储的 cache 命中率低，作为 List 时性能不如 ArrayList，除非需要经常在表头插入或删除。</p></li><li><p>Vector</p><p>废弃类。数组实现，加入了线程安全设计。默认容量为 10，容量不够时，默认翻倍。</p><p>在不要求线程安全的情况下，性能远不如 ArrayList。</p><p>在线程安全方面，它对每个单独的操作用 <code>synchronized</code> 修饰，但一般是要将一系列操作整体进行同步，没有必要对每个操作重复上锁。将 List 接口和同步强行结合在一起本身也是不好的设计。</p><p>要将 List 接口和同步设计分离，可以用 <code>Collections.synchronizedList</code> 做一个包装，程序员可以自由选择什么时候进行同步：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>syncedList</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Collections</span><span class=p>.</span><span class=na>synchronizedList</span><span class=p>(</span><span class=n>list</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...</span><span class=w>
</span></span></span></code></pre></div></li><li><p>Stack</p><p>废弃类。Stack 类是糟糕的设计，它继承自 Vector，加入了栈相关的方法（还用 <code>synchronized</code> 修饰）。这就意味着 Stack 可以随机存取，而栈是一种限制只能在栈顶存取的数据结构。可以用 ArrayDeque 代替。</p></li></ul><h3 id=set>Set</h3><ul><li><p>HashSet</p><p>HashMap 的封装，实际上就是将插入的元素作为 key，全局相同的一个对象作为 value 保存在 HashMap 中。</p></li><li><p>LinkedHashSet</p><p>LinkedHashMap 的封装，元素可以按插入顺序来遍历。LinkedHashSet 继承自 HashSet，但其构造方法调用了 HashSet 的一个构造方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>HashSet</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>initialCapacity</span><span class=p>,</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=n>loadFactor</span><span class=p>,</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>dummy</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedHashMap</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>initialCapacity</span><span class=p>,</span><span class=w> </span><span class=n>loadFactor</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>这个构造方法没有用 <code>public</code> 修饰，只提供给 LinkedHashSet 使用。因此 LinkedHashSet 最终使用的是 LinkedHashMap 来保存插入顺序。</p></li><li><p>TreeSet</p><p>TreeMap 的封装，与 HashSet 之于 HashMap 类似。保持插入的元素有序。</p></li><li><p>EnumSet</p><p>枚举类型 Set 的抽象类，提供一系列静态方法，返回继承它的实体类的实例。如果枚举数量不超过 64，则返回 RegularEnumSet 的实例，它维护一个 <code>long</code> 变量，每个比特标识一个枚举；如果枚举数量超过 64，则返回 JumboEnumSet 的实例，它使用 <code>long</code> 数组来标识。</p></li></ul><h3 id=queue>Queue</h3><ul><li><p>LinkedList</p><p>双向链表实现，实现了继承自 Queue 的 Deque 接口。作为 Queue/Deque 时性能不如 ArrayDeque。元素可以为 <code>null</code>。</p></li><li><p>ArrayDeque</p><p>数组实现，实现了 Deque 接口。比较尴尬的是没有继承 AbstractQueue。</p><p>元素不能为 <code>null</code>，Deque 接口建议禁止元素为 <code>null</code>，因为队列为空时，<code>null</code> 可以作为一些获取元素的方法的返回值。尴尬的是，LinkedList 元素可以为 <code>null</code>，当获取到元素为 <code>null</code> 时，你就获得了一个薛定谔的队列，你不知道队列到底是不是为空，除非你用 <code>isEmpty</code> 或 <code>size</code> 等方法。</p><p>数组首尾在逻辑上相连，用两个指针 <code>head</code>、<code>tail</code> 来标识队首和队尾，分别指向第一个元素的位置和最后一个元素后一个位置，指针超过范围时取模来实现循环。默认初始容量为 16，容量不够时扩大为两倍，因此容量必定是 2 的整数次幂，方便进行位运算。</p><p>Deque 的设计在我看来也很糟糕。它有很多功能重复的方法，还有 <code>removeFirstOccurrence</code>、<code>removeLastOccurrence</code> 这种意义不明的方法。</p></li><li><p>PriorityQueue</p><p>优先队列，内部使用最小堆实现，最小的元素总是在队头。元素不能为 <code>null</code>。</p><p>存放堆的数组默认初始容量为 11，容量不够时，如果容量较小则翻倍，如果较大则增加一半。元素的比较可以用自然排序（需要元素的类型实现 Comparable 接口），也可以在构造方法传入一个 Comparator 对象。</p><p>与 C++、Python 不同，Java 标准库没有提供在数组上直接建堆的方法。</p></li></ul><h2 id=map>Map</h2><p><img src=/images/java-collections-framework/map.png alt></p><ul><li><p>HashMap</p><p>使用拉链法解决哈希冲突，从 Java 8 开始，当链表过长时，转换为红黑树。key 和 value 可以为 <code>null</code>。</p></li><li><p>LinkedHashMap</p><p>继承自 HashMap，key 和 value 可以为 <code>null</code>。结点增加了 <code>before</code>、<code>after</code> 两个指针，用于建立双链表，从而维护了元素顺序。默认构造方法只维护插入顺序，也可以传入一个参数令其维护访问顺序，这可以用来实现 LRU cache。</p></li><li><p>WeakHashMap</p><p>使用拉链法解决哈希冲突。key 和 value 可以为 <code>null</code>。其结点实现继承自 WeakReference 类，仅对 key 进行弱引用。访问哈希表时，自动触发回收机制，对所有已经被回收的 key 的结点进行移除，对应 value 强引用置空。</p></li><li><p>TreeMap</p><p>红黑树实现。元素的比较可以用自然排序（需要元素类型实现 Comparable 接口），也可以在构造方法传入一个 Comparator 对象。value 可以为 <code>null</code>，如果需要 key 可为 <code>null</code>，则需要在构造方法中传入一个合适的 Comparator 对象，例如用 <code>Comparator.nullsFirst</code> 或 <code>Comparator.nullsLast</code> 进行包装。</p></li><li><p>EnumMap</p><p>key 的类型为枚举，直接使用数组保存。value 可为 <code>null</code>。</p></li><li><p>Hashtable</p><p>处于薛定谔的废弃状态。加入了同步设计，对方法用 <code>synchronized</code> 修饰。拉链法解决哈希冲突。key 和 value 不能为 <code>null</code>。</p><p>不需要线程安全时，效率不如 HashMap，需要线程安全时，效率又不如 ConcurrentHashMap，因为 Hashtable 的 <code>synchronized</code> 方法是对整个对象上锁，ConcurrentHashMap 是对表进行分段上锁。</p><p>其父类 Dictionary 已废弃，被 Map 代替。其子类 Properties 用于存取 String 类型的键值对，<code>System.getProperty</code> 方法就是一个应用。</p></li></ul><h2 id=工具类>工具类</h2><ul><li><p>Arrays</p><p>数组相关的工具类。</p><p>其中有一个 <code>asList</code> 方法，返回一个内部类 ArrayList 的实例，这个类和 java.util.ArrayList 不是同一个，而且大小不可变，Java 入门常见坑。</p></li><li><p>Collections</p><p>集合相关的工具类。例如将集合包装成同步，将 Map 包装成 Set 等。</p></li></ul></article><section class="article labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/perfect-squares/><span class="iconfont icon-article"></span>将正整数表示为若干平方数之和 Perfect Squares</a></p><p><a class=link href=/posts/prime-sieve-and-goldbach-s-conjecture/><span class="iconfont icon-article"></span>素数筛法和哥德巴赫猜想</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>