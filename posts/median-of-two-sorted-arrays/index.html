<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>求两个有序数组的中位数 Median of Two Sorted Arrays&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="求两个有序数组的中位数 Median of Two Sorted Arrays"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">求两个有序数组的中位数 Median of Two Sorted Arrays</h1><p class="article date">2017-07-24</p></section><article class="article markdown-body"><p>这是 LeetCode 上的一道题，求两个有序数组的中位数：
<a href=https://leetcode.com/problems/median-of-two-sorted-arrays/description/ target=_blank rel="noopener noreferrer">https://leetcode.com/problems/median-of-two-sorted-arrays/description/</a></p><blockquote><p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p><p><strong>Follow up:</strong> The overall run time complexity should be <code>O(log (m+n))</code>.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> nums1 = [1,3], nums2 = [2]
<strong>Output:</strong> 2.00000
<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.
</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]
<strong>Output:</strong> 2.50000
<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> nums1 = [0,0], nums2 = [0,0]
<strong>Output:</strong> 0.00000
</pre><p><strong>Example 4:</strong></p><pre><strong>Input:</strong> nums1 = [], nums2 = [1]
<strong>Output:</strong> 1.00000
</pre><p><strong>Example 5:</strong></p><pre><strong>Input:</strong> nums1 = [2], nums2 = []
<strong>Output:</strong> 2.00000
</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li></ul></blockquote><p>确定一下输入应满足的条件：两个数组的长度可以有一个为 $0$（此时中位数就是另一个数组的中位数），但不能同时为 $0$。</p><p>很容易想到时间复杂度为 $O(m+n)$ 的方法，但是 follow-up 要求复杂度为 $O(\log(m+n))$。从复杂度看应该用分治法。事实上，复杂度可以减少到 $O(\log(\min(m, n)))$。</p><h2 id=划分>划分</h2><p>设中位数为 $x$，$x$ 可将两个数组分别划分为两半：</p><pre tabindex=0><code>A[0], A[1], ..., A[i - 1] | A[i], A[i + 1], ..., A[m - 1]
B[0], B[1], ..., B[j - 1] | B[j], B[j + 1], ..., B[n - 1]
</code></pre><p>其中 $0 \le i \le m, 0 \le j \le n$。</p><p>如果满足两个条件：</p><ul><li>$i + j = \begin{cases} m - i + n - j, & \text{$m + n$ 为偶数} \\ m - i + n - j + 1, & \text{$m + n$ 为奇数} \end{cases}$</li><li>左边所有元素 $\le x \le$ 右边所有元素，</li></ul><p>则找到了适当的划分位置，且</p><p>$$x = \begin{cases} \frac{1}{2} (\max\{A[i - 1], B[j - 1]\} + \min\{A[i + 1], B[j + 1]\}), & \text{$m + n$ 为偶数} \\ \max\{A[i - 1], B[j - 1]\}, & \text{$m + n$ 为奇数} \end{cases}$$</p><p>由此问题转化为：查找这样的 $i$，且同时满足以上两个条件，即可得出中位数 $x$。</p><ul><li>根据第一个条件，在编程中可以直接用截断除法得出 $j$：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>j</span> <span class=o>=</span> <span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>-</span> <span class=n>i</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>若不考虑下标越界情况，由于两个数组升序，第二个条件等价于：</li></ul><p>$$\begin{cases} A[i - 1] \le x \leq A[i]& \\ B[j - 1] \le x \leq B[j] \end{cases} \iff \begin{cases} A[i - 1] \le B[j]& \\ B[j - 1] \le A[i] \end{cases}$$</p><h2 id=二分查找>二分查找</h2><h3 id=j-的取值范围>$j$ 的取值范围</h3><p>现考察 $j$ 的范围，$j = \frac{m + n + k}{2} - i$，其中</p><p>$$k = \begin{cases} 0, & \text{$m + n$ 为偶数} \\ 1, & \text{$m + n$ 为奇数} \end{cases}$$</p><p>$j$ 随 $i$ 递减，只需</p><p>$$\begin{cases} j_{max} = \frac{m + n + k}{2} - 0 \le n&\\ j_{min} = \frac {m + n + k}{2} - m \ge 0 \end{cases} \iff m \le n - k$$</p><p>即可保证 $0 \leq j \leq n$。</p><ul><li>当 $m + n$ 为偶数时，$k = 0$，则 $m \leq n$。</li><li>当 $m + n$ 为奇数时，$k = 1$，则 $m \leq n - 1$，又 $m$、$n$ 必为一奇一偶，因此 $m &lt; n$。</li></ul><p>综上得 $m \le n$。</p><p>因此当 $m \le n$ 时，若 $0 \le i \le m$，则必有 $0 \le j \le n$。</p><p>在编程实现时，保证数组长度 $A$ 比 $B$ 小即可。</p><h3 id=查找思路>查找思路</h3><p>要在 $i = 0, 1, &mldr;, m$ 中查找合适的 $i$，自然联想到二分查找。初始情况下，$i$ 的下界为 $0$，上界为 $m$。</p><p>若不考虑下标越界，则有以下几种情形：</p><ul><li>$\begin{cases} A[i-1] \le B[j] & \\ B[j-1] \le A[i] \end{cases}$，此时 $i$ 查找成功。</li><li>$A[i-1] > B[j]$，此时 $i$ 过大，应丢弃后半部分。</li><li>$B[j-1] > A[i]$，此时 $i$ 过小，应丢弃前半部分。</li></ul><p>考虑下标越界情况：</p><ul><li>$i = 0$，无需判断 $A[i-1] \le B[j]$。</li><li>$i = m$，无需判断 $B[j-1] \le A[i]$。</li><li>$j = 0$，无需判断 $B[j-1] \le A[i]$。</li><li>$j = n$，无需判断 $A[i-1] \le B[j]$。</li></ul><p>结合越界情况，会出现以下三种情形：</p><ul><li>$\begin{cases} i=0 \ 或\ j=n \ 或\ A[i-1] \le B[j] & \\ j=0 \ 或\ i=m \ 或\ B[j-1] \le A[i] \end{cases}$，此时 $i$ 查找成功。</li><li>$i>0 \ 且\ j &lt; n \ 且\ A[i-1] > B[j]$，此时 $i$ 过大。</li><li>$j>0 \ 且\ i &lt; m \ 且\ B[j-1] > A[i]$，此时 $i$ 过小。</li></ul><p>这样，通过二分查找，找到所需要的 $i$ 的值。</p><p>也可以反过来考虑，合适的 $0 \le i \le m$ 必定存在，先考虑 $i$ 过大和过小的情形。</p><p>例如，若 $i$ 过大，要在 $&lt; i$ 中查找，不可能有 $i = 0$ 或 $j = n$，因为 $i$ 减小同时 $j$ 增大后必定越界，而 $A[i-1] > B[j]$ 是一定成立的，所以 $i$ 过大 $\iff \begin{cases} i>0 & \\ j &lt; n & \\ A[i-1] > B[j] \end{cases}$。排除过大和过小的情形，剩下只能是查找成功的情形。</p><h2 id=计算中位数>计算中位数</h2><p>现在已经找出了划分位置，如果共有奇数个元素，则中位数为左边元素的最大值，如果共有偶数个元素，则中位数为左边最大值和右边最小值的平均数。</p><p>例如求左边最大值：</p><ul><li>若 $i = 0$，左边最大值即为 $B[j - 1]$，此时 $j > 0$ 必成立。</li><li>若 $j = 0$，左边最大值即为 $A[i - 1]$，此时 $i > 0$ 必成立。</li><li>若 $\begin{cases} i > 0 & \\ j > 0 \end{cases}$，左边最大值为 $\max\{A[i - 1], B[j - 1]\}$。</li></ul><h2 id=时间复杂度>时间复杂度</h2><p>在长度为 $m$ 的数组 $A$ 中进行二分查找，由于保证了 $m \leq n$，因此时间复杂度为 $O(\log(\min(m, n)))$。</p><h2 id=实现源码>实现源码</h2><p><a href=https://github.com/qianbinbin/leetcode target=_blank rel="noopener noreferrer">https://github.com/qianbinbin/leetcode</a></p></article><section class="article labels"><a class=tag href=/tags/leetcode/>LeetCode</a><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/print-log-in-libcore/><span class="iconfont icon-article"></span>在 Android Java 核心库 libcore 中打印 Log</a></p><p><a class=link href=/posts/decorator-pattern/><span class="iconfont icon-article"></span>装饰器模式 Decorator Pattern</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>