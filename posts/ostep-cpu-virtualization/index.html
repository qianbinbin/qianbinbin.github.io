<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>OSTEP CPU 虚拟化&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="OSTEP CPU 虚拟化"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">OSTEP CPU 虚拟化</h1><p class="article date">2021-02-06</p></section><article class="article markdown-body"><h2 id=第-4-章-抽象进程>第 4 章 抽象：进程</h2><p>进程就是运行中的程序。</p><p>OS 通过虚拟化 CPU 来提供几乎有无数个 CPU 可用的假象。一个进程只运行一个时间片，然后切换到其它进程，这就是时分共享 CPU 技术。</p><p>要实现 CPU 的虚拟化，OS 就需要一些低级机制以及一些高级智能。</p><p>机制是一些低级方法或协议，例如上下文切换，它让 OS 停止运行一个程序并开始在给定 CPU 上运行另一个程序。</p><p>在机制之上，OS 中有一些智能以策略的形式存在。策略是在 OS 内作出某种决定的算法，例如对多个程序选择一个运行的调度策略。</p><h3 id=41-抽象进程概念>4.1 抽象：进程概念</h3><p>OS 为正在运行的程序提供的抽象，就是进程。</p><p>进程的机器状态，指程序在运行时可以读取或更新的内容，包括内存和寄存器。</p><h3 id=42-进程-api>4.2 进程 API</h3><ul><li>创建：创建新进程。</li><li>销毁：强制销毁进程。</li><li>等待：等待进程停止运行。</li><li>其它控制：例如暂停和恢复。</li><li>状态：获取进程状态信息。</li></ul><h3 id=43-进程创建>4.3 进程创建</h3><ol><li><p>将代码和静态数据（如初始化变量）加载到内存中。程序最初以可执行格式驻留在磁盘上，OS 从磁盘读取这些字节并放到内存中。</p><p>早期 OS 中，加载在程序运行前全部完成，现代 OS 使用惰性加载，即只在程序执行时加载所需的代码或数据片段，这是通过分页和交换机制实现的。</p></li><li><p>OS 为程序的运行时栈分配内存。例如 C 程序使用栈存放局部变量、函数参数和返回地址。OS 可能会初始化栈，例如为 <code>main()</code> 函数填入 <code>argc</code> 和 <code>argv</code> 参数。</p><p>OS 也可能为程序分配堆内存。在 C 中调用 <code>malloc()</code> 申请空间，<code>free()</code> 释放。</p></li><li><p>OS 执行一些初始化任务，尤其是 I/O 相关任务。例如 UNIX 默认每个进程都有 3 个打开的文件描述符：标准输入、输出和错误。</p></li><li><p>OS 启动程序，在入口处运行，即 <code>main()</code>。通过跳转到 <code>main()</code> 例程，OS 将 CPU 控制权转移到新创建的进程中。</p></li></ol><h3 id=44-进程状态>4.4 进程状态</h3><ul><li>运行</li><li>就绪</li><li>阻塞</li></ul><p><img src=/images/ostep-cpu-virtualization/process-state-transitions.png alt></p><h3 id=45-数据结构>4.5 数据结构</h3><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/xv6-public/proc.h style=color:lightslategrey;font-size:.8em>proc.h</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//PAGEBREAK: 17
</span></span></span><span class=line><span class=cl><span class=c1>// Saved registers for kernel context switches.
</span></span></span><span class=line><span class=cl><span class=c1>// Don&#39;t need to save all the segment registers (%cs, etc),
</span></span></span><span class=line><span class=cl><span class=c1>// because they are constant across kernel contexts.
</span></span></span><span class=line><span class=cl><span class=c1>// Don&#39;t need to save %eax, %ecx, %edx, because the
</span></span></span><span class=line><span class=cl><span class=c1>// x86 convention is that the caller has saved them.
</span></span></span><span class=line><span class=cl><span class=c1>// Contexts are stored at the bottom of the stack they
</span></span></span><span class=line><span class=cl><span class=c1>// describe; the stack pointer is the address of the context.
</span></span></span><span class=line><span class=cl><span class=c1>// The layout of the context matches the layout of the stack in swtch.S
</span></span></span><span class=line><span class=cl><span class=c1>// at the &#34;Switch stacks&#34; comment. Switch doesn&#39;t save eip explicitly,
</span></span></span><span class=line><span class=cl><span class=c1>// but it is on the stack and allocproc() manipulates it.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>edi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>esi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>ebx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>ebp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>eip</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=n>procstate</span> <span class=p>{</span> <span class=n>UNUSED</span><span class=p>,</span> <span class=n>EMBRYO</span><span class=p>,</span> <span class=n>SLEEPING</span><span class=p>,</span> <span class=n>RUNNABLE</span><span class=p>,</span> <span class=n>RUNNING</span><span class=p>,</span> <span class=n>ZOMBIE</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Per-process state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>proc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>sz</span><span class=p>;</span>                     <span class=c1>// Size of process memory (bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>pde_t</span><span class=o>*</span> <span class=n>pgdir</span><span class=p>;</span>                <span class=c1>// Page table
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=o>*</span><span class=n>kstack</span><span class=p>;</span>                <span class=c1>// Bottom of kernel stack for this process
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>enum</span> <span class=n>procstate</span> <span class=n>state</span><span class=p>;</span>        <span class=c1>// Process state
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>                     <span class=c1>// Process ID
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>parent</span><span class=p>;</span>         <span class=c1>// Parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>trapframe</span> <span class=o>*</span><span class=n>tf</span><span class=p>;</span>        <span class=c1>// Trap frame for current syscall
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>context</span> <span class=o>*</span><span class=n>context</span><span class=p>;</span>     <span class=c1>// swtch() here to run process
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=o>*</span><span class=n>chan</span><span class=p>;</span>                  <span class=c1>// If non-zero, sleeping on chan
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>killed</span><span class=p>;</span>                  <span class=c1>// If non-zero, have been killed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>ofile</span><span class=p>[</span><span class=n>NOFILE</span><span class=p>];</span>  <span class=c1>// Open files
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>cwd</span><span class=p>;</span>           <span class=c1>// Current directory
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>               <span class=c1>// Process name (debugging)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></div></figure><p><code>context</code> 结构体是寄存器上下文。进程停止时，将寄存器内容保存到内存，进程恢复时，将内容取回到寄存器。这种技术叫上下文切换。</p><p><code>procstate</code> 用于表示进程状态。</p><p>ZOMBIE 称为僵尸状态，表示进程处于已退出但尚未清理的最终状态。这个状态可用于其他进程（通常是父进程）检查进程的返回代码。完成后，父进程将进行最后一次调用（如 <code>wait()</code>）以等待子进程完成，并告诉 OS 可以清理这个进程的数据结构。</p><p><code>proc</code> 结构体是 PCB（进程控制块）。</p><h2 id=第-5-章-进程-api>第 5 章 进程 API</h2><h3 id=51-fork-系统调用>5.1 fork() 系统调用</h3><p><code>fork()</code> 是 OS 提供的创建新进程的方法。</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-code/cpu-api/p1.c style=color:lightslategrey;font-size:.8em>cpu-api/p1.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello world (pid:%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// fork failed; exit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// child (new process)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello, I am child (pid:%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// parent goes down this path (original process)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello, I am parent of %d (pid:%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	       <span class=n>rc</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./p1
</span></span><span class=line><span class=cl>hello world <span class=o>(</span>pid:29146<span class=o>)</span>
</span></span><span class=line><span class=cl>hello, I am child <span class=o>(</span>pid:29147<span class=o>)</span>
</span></span><span class=line><span class=cl>hello, I am parent of <span class=m>29147</span> <span class=o>(</span>pid:29146<span class=o>)</span>
</span></span></code></pre></div><p>新创建的进行几乎与调用的进程完全一样，在 OS 看来就好像有两个 <code>p1</code> 的副本在运行，两者都将从 <code>fork()</code> 系统调用返回。</p><p><strong>但子进程不会从 <code>main()</code> 函数开始执行，而是紧接着 <code>fork()</code> 之后。父进程获得的返回值是子进程的 PID，子进程获得的返回值是 0。这样就可以在编码中处理两种不同的情况。</strong></p><p>子进程和父进程的先后顺序是不确定的。</p><h3 id=52-wait-系统调用>5.2 wait() 系统调用</h3><p>有时父进程需要等待子进程执行完毕，此时可以用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用。</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-code/cpu-api/p2.c style=color:lightslategrey;font-size:.8em>cpu-api/p2.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello world (pid:%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// fork failed; exit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// child (new process)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello, I am child (pid:%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>	<span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// parent goes down this path (original process)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>wc</span> <span class=o>=</span> <span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello, I am parent of %d (wc:%d) (pid:%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	       <span class=n>rc</span><span class=p>,</span> <span class=n>wc</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./p2
</span></span><span class=line><span class=cl>hello world <span class=o>(</span>pid:29266<span class=o>)</span>
</span></span><span class=line><span class=cl>hello, I am child <span class=o>(</span>pid:29267<span class=o>)</span>
</span></span><span class=line><span class=cl>hello, I am parent of <span class=m>29267</span> <span class=o>(</span>rc_wait:29267<span class=o>)</span> <span class=o>(</span>pid:29266<span class=o>)</span>
</span></span></code></pre></div><h3 id=53-exec-系统调用>5.3 exec() 系统调用</h3><p><code>exec()</code> 系统调用可以让子进程执行与父进程不同的程序。</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-code/cpu-api/p3.c style=color:lightslategrey;font-size:.8em>cpu-api/p3.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello world (pid:%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// fork failed; exit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// child (new process)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello, I am child (pid:%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span><span class=n>myargs</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>myargs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nf>strdup</span><span class=p>(</span><span class=s>&#34;wc&#34;</span><span class=p>);</span>   <span class=c1>// program: &#34;wc&#34; (word count)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>myargs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nf>strdup</span><span class=p>(</span><span class=s>&#34;p3.c&#34;</span><span class=p>);</span> <span class=c1>// argument: file to count
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>myargs</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>           <span class=c1>// marks end of array
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>execvp</span><span class=p>(</span><span class=n>myargs</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>myargs</span><span class=p>);</span>  <span class=c1>// runs word count
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;this shouldn&#39;t print out&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// parent goes down this path (original process)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>wc</span> <span class=o>=</span> <span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello, I am parent of %d (wc:%d) (pid:%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	       <span class=n>rc</span><span class=p>,</span> <span class=n>wc</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></figure><p>这里在子进程中调用 <code>wc p3.c</code> 来统计字符数（源码与书中不同，因此结果不同）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ./p3
</span></span><span class=line><span class=cl>hello world <span class=o>(</span>pid:29383<span class=o>)</span> hello, I am child <span class=o>(</span>pid:29384<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>29</span> <span class=m>107</span> <span class=m>1030</span> p3.c
</span></span><span class=line><span class=cl>hello, I am parent of <span class=m>29384</span> <span class=o>(</span>rc_wait:29384<span class=o>)</span> <span class=o>(</span>pid:29383<span class=o>)</span>
</span></span></code></pre></div><p><code>exec()</code> 会从可执行程序中加载代码和静态数据，并覆盖自身，堆栈等内存空间也会初始化，然后 OS 执行该程序，将参数传递给该进程。</p><p><code>exec()</code> 不会创建新进程，而是用当前程序替换。<code>exec()</code> 成功调用后不会返回。</p><h3 id=54-为什么这样设计-api>5.4 为什么这样设计 API</h3><p>将 <code>fork()</code> 与 <code>exec()</code> 分离，可以在 <code>fork()</code> 之后、<code>exec()</code> 之前运行一些代码，例如改变环境，从而实现特定功能。</p><p>shell 也是一个用户程序。当运行一个命令时，shell 先在文件系统中找到这个可执行程序，调用 <code>fork()</code> 创建新进程，并调用 <code>exec()</code> 来执行它，调用 <code>wait()</code> 来等待该命令完成。子进程执行结束后，shell 从 <code>wait()</code> 返回，等待用户输入下一条命令。</p><p>例如，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ wc p3.c &gt; newfile.txt
</span></span></code></pre></div><p><code>wc</code> 的输出结果被重定向到 <code>newfile.txt</code> 中，shell 实现的方式为，当创建子进程后，在调用 <code>exec()</code> 之前先关闭标准输出，打开文件 <code>newfile.txt</code>，这样 <code>wc</code> 的输出结果就被发送到该文件。</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-code/cpu-api/p4.c style=color:lightslategrey;font-size:.8em>cpu-api/p4.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// fork failed; exit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// child: redirect standard output to a file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>close</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>	<span class=nf>open</span><span class=p>(</span><span class=s>&#34;./p4.output&#34;</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=o>|</span><span class=n>O_WRONLY</span><span class=o>|</span><span class=n>O_TRUNC</span><span class=p>,</span> <span class=n>S_IRWXU</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// now exec &#34;wc&#34;...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>char</span> <span class=o>*</span><span class=n>myargs</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>myargs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nf>strdup</span><span class=p>(</span><span class=s>&#34;wc&#34;</span><span class=p>);</span>   <span class=c1>// program: &#34;wc&#34; (word count)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>myargs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nf>strdup</span><span class=p>(</span><span class=s>&#34;p4.c&#34;</span><span class=p>);</span> <span class=c1>// argument: file to count
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>myargs</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>           <span class=c1>// marks end of array
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>execvp</span><span class=p>(</span><span class=n>myargs</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>myargs</span><span class=p>);</span>  <span class=c1>// runs word count
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// parent goes down this path (original process)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>wc</span> <span class=o>=</span> <span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>assert</span><span class=p>(</span><span class=n>wc</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></figure><p>UNIX 管道也是用类似方式实现的，但用的是 <code>pipe()</code> 系统调用。一个进程的输出被连接到一个内核管道上（如队列），另一个进程的输入也被连接到同一管道上，因此前一个进程的输出无缝作为后一个进程的输入。例如 <code>grep -o foo file | wc -l</code>。</p><h3 id=55-其他-api>5.5 其他 API</h3><p>UNIX 还有其他与进程交互的方式，如 <code>kill()</code> 系统调用可以向进程发送信号，要求其睡眠、终止等。</p><h3 id=作业>作业</h3><ol><li></li></ol><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-api/p1.c style=color:lightslategrey;font-size:.8em>cpu-api/p1.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child, pid=%d, x=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child, pid=%d, x=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent, pid=%d, x=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent, pid=%d, x=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><ol start=2><li></li></ol><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-api/p2.c style=color:lightslategrey;font-size:.8em>cpu-api/p2.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;./p2.output&#34;</span><span class=p>,</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_WRONLY</span> <span class=o>|</span> <span class=n>O_TRUNC</span><span class=p>,</span> <span class=mo>0644</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=s>&#34;child</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=s>&#34;parent</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><ol start=3><li></li></ol><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-api/p3.c style=color:lightslategrey;font-size:.8em>cpu-api/p3.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;goodbye</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><ol start=4><li>根据 <a href=https://en.wikipedia.org/wiki/Exec_%28system_call%29 target=_blank rel="noopener noreferrer">https://en.wikipedia.org/wiki/Exec_(system_call)</a>：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execl</span><span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>arg0</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execle</span><span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>arg0</span><span class=p>,</span> <span class=p>...,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execlp</span><span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>arg0</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execv</span><span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execve</span><span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execvp</span><span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>argv</span><span class=p>[]);</span>
</span></span></code></pre></div><blockquote><p>e – An array of pointers to environment variables is explicitly passed to the new process image.</p><p>l – Command-line arguments are passed individually (a list) to the function.</p><p>p – Uses the PATH environment variable to find the file named in the file argument to be executed.</p><p>v – Command-line arguments are passed to the function as an array (vector) of pointers.</p></blockquote><ul><li><code>e</code>：<code>environment variables</code>，指定环境变量。</li><li><code>l</code>：<code>list</code>，通过列表传递参数。</li><li><code>p</code>：<code>PATH environment variable</code>，即 <code>PATH</code> 环境变量，从 <code>PATH</code> 中查找可执行程序。</li><li><code>v</code>：<code>vector</code>，通过数组传递参数。</li></ul><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-api/p4.c style=color:lightslategrey;font-size:.8em>cpu-api/p4.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// printf(&#34;execl\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// execl(&#34;/bin/ls&#34;, &#34;/bin/ls&#34;, (char *) NULL);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=c1>// printf(&#34;execlp\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// execlp(&#34;ls&#34;, &#34;ls&#34;, (char *) NULL);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=c1>// printf(&#34;execv\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// char *cvargs[2];
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// cvargs[0] = strdup(&#34;/bin/ls&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// cvargs[1] = NULL;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// execv(cvargs[0], cvargs);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;execvp</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span><span class=n>cvpargs</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>cvpargs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nf>strdup</span><span class=p>(</span><span class=s>&#34;ls&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cvpargs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>execvp</span><span class=p>(</span><span class=n>cvpargs</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>cvpargs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><ol start=5><li>父进程调用 <code>wait()</code> 返回的是子进程的 <code>pid</code>，子进程调用 <code>wait()</code> 返回值为 <code>-1</code>：</li></ol><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-api/p5.c style=color:lightslategrey;font-size:.8em>cpu-api/p5.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>wc</span> <span class=o>=</span> <span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child, pid=%d, wc=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>wc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>wc</span> <span class=o>=</span> <span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent, pid=%d, wc=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>wc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><ol start=6><li><code>wait(&amp;wstatus)</code> 等价于 <code>waitpid(-1, &amp;wstatus, 0)</code>：</li></ol><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-api/p6.c style=color:lightslategrey;font-size:.8em>cpu-api/p6.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child, pid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>wc</span> <span class=o>=</span> <span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent, pid=%d, wc=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>wc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><ol start=7><li>关闭标准输出后，<code>printf()</code> 不会有内容输出：</li></ol><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-api/p7.c style=color:lightslategrey;font-size:.8em>cpu-api/p7.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child, pid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent, pid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><ol start=8><li>使用 <code>pipe()</code> 系统调用创建管道，使用 <code>dup2()</code> 系统调用将标准输入和输出重定向到管道两端：</li></ol><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-api/p8.c style=color:lightslategrey;font-size:.8em>cpu-api/p8.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pipefd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>pipe</span><span class=p>(</span><span class=n>pipefd</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;pipe failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>rc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child, pid=%d, i=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// writer
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>dup2</span><span class=p>(</span><span class=n>pipefd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>STDOUT_FILENO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>pipefd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>pipefd</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;writer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// reader
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>dup2</span><span class=p>(</span><span class=n>pipefd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>STDIN_FILENO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>pipefd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>pipefd</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=kt>char</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=nf>read</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent, pid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>dup2</span><span class=p>(</span><span class=kt>int</span> <span class=n>oldfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>newfd</span><span class=p>);</span>
</span></span></code></pre></div><p><code>dup2()</code> 将 <code>newfd</code> 指向 <code>oldfd</code>，如果 <code>newfd</code> 已经打开，则首先会被关闭，然后再指向 <code>oldfd</code>。这样在访问 <code>newfd</code> 时，实际上访问的是 <code>oldfd</code>。</p><p><code>reader</code> 进程中最后 3 行是读取标准输入并输出，如果将其注释，则不会有 <code>writer</code> 输出，可见实现了将一个进程的标准输出连接到另一个进程的标准输入。</p><h2 id=第-6-章-机制受限直接执行>第 6 章 机制：受限直接执行</h2><h3 id=61-基本技巧受限直接执行>6.1 基本技巧：受限直接执行</h3><p>如果直接在 CPU 上执行程序，会有两个问题：</p><ol><li>OS 如何确保程序不做任何我们不希望它做的事？</li><li>OS 如何实现虚拟化 CPU，即时分共享？</li></ol><h3 id=62-问题-1受限制的操作>6.2 问题 1：受限制的操作</h3><p>例如，如果用户进程可以任意访问磁盘 I/O，那么文件系统权限保护就会失效。为此必须引入新的处理器模式。</p><ul><li>用户模式：用户模式下运行的代码会受到限制，例如无法发起 I/O 请求，这样会导致处理器异常，OS 可能会终止该进程。</li><li>内核模式：OS 以这种模式运行，运行代码可以任意进行特权操作，如发起 I/O 请求、使用受限指令等。</li></ul><p>如果用户希望执行某种特权操作，现代硬件提供了用户程序执行系统调用的能力，系统调用允许内核向用户程序暴露某些关键功能，如访问文件系统、创建和销毁进程、与其他进程通信、分配内存等。</p><p>要执行系统调用，程序必须执行特殊的陷阱指令，该指令跳入内核，并将特权级别提升到内核模式。完成工作后，OS 调用特殊的从陷阱返回指令，返回到发起调用的用户程序中，同时回到用户模式。</p><p>执行陷阱指令时，硬件需要将调用者的寄存器保存起来，以便在 OS 发出从陷阱指令时正确返回。例如，在 x86 上，处理器会将程序计数器、标志和其他一些寄存器送入每个进程的内核栈。从陷阱返回时，从栈弹出这些值，并恢复执行用户程序。</p><p>系统调用看起来就像过程调用，实际上系统调用就是将陷阱指令隐藏在过程调用中。C 库中的系统调用部分是用汇编手工编码的。</p><p>陷阱如何知道在 OS 内运行哪些代码？显然不应该由用户程序指定。这是由陷阱表来实现的。</p><p>机器启动时在内核模式下执行，根据需要配置机器硬件，设置陷阱表。OS 首先做的事之一，就是告诉硬件在发生异常事件时要运行哪些代码。</p><p>当发生中断时，OS 通常通过某种特殊指令，通知硬件这些陷阱处理程序的位置。一旦硬件被通知，它就会记住这些处理程序的位置，直到重启。这种指令也是特权操作。</p><p>假设每个进程都有一个内核栈，用于在进入和离开内核时，保存和恢复寄存器：</p><p><img src=/images/ostep-cpu-virtualization/limited-direct-excution-protocol.png alt></p><p>LDE 协议（Limited Direct Excution Protocol，受限直接执行协议）有两个阶段：</p><ol><li>系统启动时，内核初始化陷阱表，并且 CPU 记住它的位置。内核通过特权指令执行此操作。</li><li>运行进程时，内核设置一些内容，然后使用从陷阱返回指令，将 CPU 切换到用户模式并开始运行该进程。进程发出系统调用时，会重新陷入 OS，OS 处理完成后再次通过从陷阱返回指令，返回进程。进程完成工作后，从 <code>main()</code> 返回，然后通过 <code>exit()</code> 系统调用等方式陷入 OS。OS 清理干净，至此完成。</li></ol><h3 id=63-问题-2在进程之间切换>6.3 问题 2：在进程之间切换</h3><p>OS 实现进程之间的切换，但进程在 CPU 运行时，意味着 OS 不在运行，于是有了问题：如何让 OS 重新获得 CPU 控制权，以便实现进程切换？</p><h4 id=协作方式等待系统调用>协作方式：等待系统调用</h4><p>早期 OS 采用这种方式，OS 相信进程会合理运行，假定运行时间长的进程会定期放弃 CPU。</p><p>大多数进程通过系统调用将 CPU 控制权交给 OS。这样的 OS 通常包括一个显式的 <code>yield</code> 系统调用，它除了移交控制权外什么都不做。</p><p>如果进程执行了非法操作，也会将控制权交给 OS。例如将 <code>0</code> 作为除数，或访问应该无法访问的内存，就会陷入 OS。OS 再次控制 CPU，且可能会终止该进程。</p><p>这种方式可能造成 CPU 一直被进程占用。</p><h4 id=非协作方式操作系统进行控制>非协作方式：操作系统进行控制</h4><p>如果进程不协作，OS 通过时钟中断获取 CPU 控制权。</p><p>时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，OS 中预先配置的中断处理程序会运行，OS 重新获得 CPU 控制权。</p><p>首先，就像系统调用一样，OS 必须通知硬件在时钟中断发生时运行哪些代码，这是在启动时完成的。</p><p>其次，在启动过程中，OS 必须启动时钟，这是特权操作。</p><p>一旦时钟开始，OS 就可以自由运行用户程序了，因为控制权最终会归还给它。时钟也可以关闭，这也是特权操作。</p><p>与显式系统调用陷入内核时相似，发生时钟中断时，硬件需要保存进程的状态如寄存器，执行从陷阱返回指令时再恢复。</p><h4 id=保存和恢复上下文>保存和恢复上下文</h4><p>当 OS 重新获取控制权后，必须决定是继续运行当前的进程，还是切换到另一个进程，将由调度程序通过调度策略作出决定。调度程序是 OS 的一部分。</p><p>上下文切换：OS 执行底层汇编代码，保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复另一个进程的寄存器及内核栈指针。</p><p>进程 A 正在运行，然后被切换到进程 B 的简略过程：</p><p><img src=/images/ostep-cpu-virtualization/limited-direct-excution-protocol-timer-interrupt.png alt></p><p>书中的图不是很恰当，看上去是直接把 A 切换到 B。</p><p>xv6 上下文其实就是 <code>context</code> 结构体：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/xv6-public/proc.h style=color:lightslategrey;font-size:.8em>proc.h</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//PAGEBREAK: 17
</span></span></span><span class=line><span class=cl><span class=c1>// Saved registers for kernel context switches.
</span></span></span><span class=line><span class=cl><span class=c1>// Don&#39;t need to save all the segment registers (%cs, etc),
</span></span></span><span class=line><span class=cl><span class=c1>// because they are constant across kernel contexts.
</span></span></span><span class=line><span class=cl><span class=c1>// Don&#39;t need to save %eax, %ecx, %edx, because the
</span></span></span><span class=line><span class=cl><span class=c1>// x86 convention is that the caller has saved them.
</span></span></span><span class=line><span class=cl><span class=c1>// Contexts are stored at the bottom of the stack they
</span></span></span><span class=line><span class=cl><span class=c1>// describe; the stack pointer is the address of the context.
</span></span></span><span class=line><span class=cl><span class=c1>// The layout of the context matches the layout of the stack in swtch.S
</span></span></span><span class=line><span class=cl><span class=c1>// at the &#34;Switch stacks&#34; comment. Switch doesn&#39;t save eip explicitly,
</span></span></span><span class=line><span class=cl><span class=c1>// but it is on the stack and allocproc() manipulates it.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>edi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>esi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>ebx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>ebp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>eip</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></figure><p>xv6 上下文切换<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，实际上是先将原进程上下文切换到当前 CPU 的 <code>scheduler</code>（也是 <code>context</code> 结构体），然后再切换到新进程。</p><p><img src=https://miro.medium.com/max/1400/1*O9fKaBEgNhoR45xZFBjvxQ.png alt></p><p>调用 <code>swtch()</code> 时，栈顶元素分别为：</p><ul><li><code>%eip</code>：调用时自动将其下一条指令地址压栈。</li><li>CPU 的 <code>scheduler</code>：指向一个 <code>context</code> 结构体。</li><li>原进程的 <code>context</code> 的指针（注意这里变量与结构体同名）：指针的指针，这是为了能修改原进程的 <code>context</code> 指向。</li></ul><p>上下文切换代码（书中使用的是旧版，故不一致）：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/xv6-public/swtch.S style=color:lightslategrey;font-size:.8em>swtch.S</a></figcaption><pre tabindex=0><code class=language-x86asm data-lang=x86asm># Context switch
#
#   void swtch(struct context **old, struct context *new);
# 
# Save the current registers on the stack, creating
# a struct context, and save its address in *old.
# Switch stacks to new and pop previously-saved registers.

.globl swtch
swtch:
  movl 4(%esp), %eax
  movl 8(%esp), %edx

  # Save old callee-saved registers
  pushl %ebp
  pushl %ebx
  pushl %esi
  pushl %edi

  # Switch stacks
  movl %esp, (%eax)
  movl %edx, %esp

  # Load new callee-saved registers
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret
</code></pre></figure><p><code>swtch()</code> 首先将 <code>old</code> 和 <code>new</code> 分别保存到 <code>%eax</code> 和 <code>%edx</code>，然后将其余寄存器入栈：</p><p><img src=https://miro.medium.com/max/1400/1*ixP6n0S0c8hinWuxyvjijA.png alt></p><p>这样栈顶元素与 <code>context</code> 结构体完全一致。</p><p>接着 <code>movl %esp, (%eax)</code> 将 <code>*old</code>（即原进程的 <code>context</code>）指向栈顶，相当于 <code>&amp;p->context = %esp</code>，然后 <code>movl %edx, %esp</code> 将栈指针切换为 <code>new</code>（即 <code>scheduler</code>）。</p><p>最后从栈顶依次弹出寄存器（顺序与入栈相反）。</p><p>之后再选择合适的新进程，使用 <code>swtch()</code> 切换其上下文。</p><h3 id=作业-1>作业</h3><p>测试环境：物理机为搭载 i7-7700HQ 的 MacBook Pro 2017，使用 VMware 运行 Debian 10.8，分配一个 CPU 核心。</p><p>测量系统调用开销：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-mechanisms/syscall-bench.c style=color:lightslategrey;font-size:.8em>cpu-mechanisms/syscall-bench.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/null&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>1000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>timeval</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>gettimeofday</span><span class=p>(</span><span class=o>&amp;</span><span class=n>start</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>gettimeofday</span><span class=p>(</span><span class=o>&amp;</span><span class=n>end</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>us</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>end</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>-</span> <span class=n>start</span><span class=p>.</span><span class=n>tv_sec</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1000000</span> <span class=o>+</span> <span class=n>end</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>-</span> <span class=n>start</span><span class=p>.</span><span class=n>tv_usec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%ld ns</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>us</span> <span class=o>*</span> <span class=mi>1000</span> <span class=o>/</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>Debian 虚拟机上的结果比物理机还要少：</p><pre tabindex=0><code>417 ns
</code></pre><p>测量上下文切换开销：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/ostep-homework/cpu-mechanisms/context-switch-bench.c style=color:lightslategrey;font-size:.8em>cpu-mechanisms/context-switch-bench.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sched.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pfd1</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>pfd2</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>pipe</span><span class=p>(</span><span class=n>pfd1</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=nf>pipe</span><span class=p>(</span><span class=n>pfd2</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;pipe failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;fork failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf1</span><span class=p>,</span> <span class=n>buf2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>100000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>pfd1</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>pfd2</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>read</span><span class=p>(</span><span class=n>pfd1</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>buf1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>write</span><span class=p>(</span><span class=n>pfd2</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>buf2</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>pfd1</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>pfd2</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>timeval</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>gettimeofday</span><span class=p>(</span><span class=o>&amp;</span><span class=n>start</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>write</span><span class=p>(</span><span class=n>pfd1</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>buf1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>read</span><span class=p>(</span><span class=n>pfd2</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>buf2</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>gettimeofday</span><span class=p>(</span><span class=o>&amp;</span><span class=n>end</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>us</span> <span class=o>=</span> <span class=p>(</span><span class=n>end</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>-</span> <span class=n>start</span><span class=p>.</span><span class=n>tv_sec</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1000000</span> <span class=o>+</span> <span class=n>end</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>-</span>
</span></span><span class=line><span class=cl>                  <span class=n>start</span><span class=p>.</span><span class=n>tv_usec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%ld ns</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>us</span> <span class=o>*</span> <span class=mi>1000</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>/</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>这里有两个进程，两个管道，父进程向其中一个管道写入，从另一个读取，子进程相反。</p><p>在一次循环中，父进程写入后等待读取，故阻塞，子进程读取并写入，再次等待读取，故阻塞，切换回父进程。因此一次循环有两次上下文切换。</p><p>由于只分配一个核心，不用考虑多核的问题，否则需要把进程绑定到同一核心。Linux 上使用 <code>sched_setaffinity()</code> 系统调用来实现。</p><p>测试结果：</p><pre tabindex=0><code>1911 ns
</code></pre><p>这一结果可能不准确，因为其他进程也运行在同一核心。</p><p>但一般的进程在切换上下文时，还要切换 Cache、TLB 等，开销会更大。</p><h2 id=第-7-章-进程调度介绍>第 7 章 进程调度：介绍</h2><h3 id=72-调度指标>7.2 调度指标</h3><p>$$T_{周转时间} = T_{完成时间} - T_{到达时间}$$</p><h3 id=73-先进先出fifo>7.3 先进先出（FIFO）</h3><p>即先来先服务（FCFS），非抢占式。</p><h3 id=74-最短作业优先sjf>7.4 最短作业优先（SJF）</h3><p>非抢占式，要求作业同时到达且时间已知。</p><h3 id=75-最短完成时间优先stcf>7.5 最短完成时间优先（STCF）</h3><p>即抢占式 SJF，每当新作业到达，选择剩余时间最短的进行调度。</p><h3 id=76-新度量指标响应时间>7.6 新度量指标：响应时间</h3><p>$$T_{响应时间} = T_{首次运行} - T_{到达时间}$$</p><h3 id=77-轮转>7.7 轮转</h3><p>轮转调度：在一个时间片内运行一个作业，然后切换到下一个，反复执行。</p><p>时间片长度必须是时钟中断周期的倍数。上下文切换的开销不仅来自寄存器，还有 Cache、TLB、分支预测器等硬件，必须权衡时间片长度。</p><p>周转时间长，响应时间短。</p><h3 id=78-结合-io>7.8 结合 I/O</h3><p>调度程序在作业发起 I/O 请求时将其阻塞，切换到另一个作业，在 I/O 完成时将其由阻塞变为就绪。</p><h2 id=第-8-章-调度多级反馈队列mlfq>第 8 章 调度：多级反馈队列（MLFQ）</h2><p>目标是优化周转时间、降低响应时间。</p><h3 id=81-两条基本原则>8.1 两条基本原则</h3><ul><li>规则 1：只运行高优先级作业，较低级作业不会运行。</li><li>规则 2：作业优先级相等，则轮转运行。</li></ul><h3 id=82-改变优先级>8.2 改变优先级</h3><ul><li>规则 3：作业开始时放在最高优先级。</li><li>规则 4a：作业用完时间片后，降低其优先级（移入下一级队列）。</li><li>规则 4b：如果作业在其时间片内主动释放 CPU，则优先级不变。</li></ul><p>这样就假定作业是短作业，如果确实是短作业则会很快执行完毕，否则移入低优先级，这时 MLFQ 类似 SJF。</p><p>如果有 I/O，则对于大量 I/O 操作（如用户键盘交互）的作业，根据规则 4b，优先级不变，会很快得到响应，可见对交互型作业也有利。</p><p>存在的问题：</p><ol><li>如果短作业过多，则长作业会长时间得不到 CPU 而饥饿。</li><li>程序可能在一段时间内表现为计算密集型，一段时间表现为交互型。</li><li>程序可以模拟 I/O 主动放弃 CPU 来欺骗调度程序，长时间占用 CPU。</li></ol><h3 id=83-提升优先级>8.3 提升优先级</h3><p>为解决问题 1 和 2，增加新规则：</p><ul><li>规则 5：每过一段时间 S，就将系统中所有作业重新加入最高优先级队列。</li></ul><h3 id=84-计时方式>8.4 计时方式</h3><p>为解决问题 3，重写规则 4a 和 4b：</p><ul><li>规则 4：一旦作业用完在其队列对应的时间配额，则移入下一队列。</li></ul><h3 id=85-其他问题>8.5 其他问题</h3><ol><li>应配置多少队列？</li><li>每一级队列时间片多大？</li><li>每过多久提升一次优先级（巫毒常量应为多大）？</li></ol><p>应避免设置巫毒常量，例如可以让系统自己去学习一个合适的值。</p><h2 id=第-9-章-调度比例份额>第 9 章 调度：比例份额</h2><p>比例份额调度又称公平份额调度，其目标是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。</p><h3 id=91-彩票调度>9.1 彩票调度</h3><p>每个进程拥有一定彩票数，其占系统总彩票数的百分比，就是其占用资源的份额。相当于权重。</p><p>彩票调度按照彩票数，概率性选择进程来运行。</p><p>这其中利用了随机性，至少有 3 点优势：</p><ol><li>避免奇怪的边角情况。例如 LRU 算法可能在有重复序列的情况下表现很差。</li><li>轻量，几乎无需记录状态，只需记录彩票数。</li><li>快速。</li></ol><p>如何分配彩票数是关键问题。</p><h3 id=96-步长调度>9.6 步长调度</h3><p>由于采用了随机性，彩票调度在作业较短的情况下可能不会产生正确的比例。</p><p>步长调度是确定性的比例分配算法。</p><p>每个进程有一个步长和行程，步长与彩票数成反比。每次选择行程最小的运行，运行后行程值增加一个步长。</p><p>彩票调度的优势在于，不需要记录这些全局状态。而且步长调度初始行程值也难以设置，如果设置为 0 的话就会长时间独占 CPU 了，而彩票调度无需考虑。</p><h3 id=97-小结>9.7 小结</h3><p>比例份额没有广泛使用，主要因为：</p><ol><li>不能很好地适应 I/O。</li><li>彩票数如何分配是个问题。</li></ol><h3 id=linux-完全公平调度cfs>Linux 完全公平调度（CFS）</h3><p>CFS（Completely Fair Scheduler，完全公平调度）<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>中文版没有介绍。</p><p>CFS 设定一个调度周期 <code>sched_latency</code>，CPU 运行的所有进程平均分配这个周期。这里分配的时间片不是绝对平均的，而是加权的虚拟运行时间。</p><p>调度周期并不是无限可分的。当进程过多时，每个进程分配到的时间片就会过短，如果进程频繁切换，大量 CPU 时间被浪费在切换上，于是设定一个最小值 <code>min_granularity</code>，时间片不得小于这个值，同时调度周期也会变大。</p><p>时钟中断触发后，CFS 判断当前进程是否用完时间片，并进行切换。进程的时间片不一定是时钟周期的倍数，所以短期内可能不会被调度，但长期来看仍然是公平的。</p><p>对每个进程累积记录虚拟运行时间 <code>vruntime</code>，每次从当前 CPU 的运行进程中选择 <code>vruntime</code> 最小的进行调度。虚拟运行时间与实际运行时间成正比，与进程的权重成反比：</p><p>$$vruntime_i = vruntime_i + \frac{weight_0}{weight_i} \cdot runtime_i$$</p><p>$weight_0$ 是优先级为 0 的权重。优先级和权重的映射关系，记录在 <code>prio_to_weight</code> 数组中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>prio_to_weight</span><span class=p>[</span><span class=mi>40</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* -20 */</span> <span class=mi>88761</span><span class=p>,</span> <span class=mi>71755</span><span class=p>,</span> <span class=mi>56483</span><span class=p>,</span> <span class=mi>46273</span><span class=p>,</span> <span class=mi>36291</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* -15 */</span> <span class=mi>29154</span><span class=p>,</span> <span class=mi>23254</span><span class=p>,</span> <span class=mi>18705</span><span class=p>,</span> <span class=mi>14949</span><span class=p>,</span> <span class=mi>11916</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* -10 */</span> <span class=mi>9548</span><span class=p>,</span> <span class=mi>7620</span><span class=p>,</span> <span class=mi>6100</span><span class=p>,</span> <span class=mi>4904</span><span class=p>,</span> <span class=mi>3906</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* -5 */</span> <span class=mi>3121</span><span class=p>,</span> <span class=mi>2501</span><span class=p>,</span> <span class=mi>1991</span><span class=p>,</span> <span class=mi>1586</span><span class=p>,</span> <span class=mi>1277</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 0 */</span> <span class=mi>1024</span><span class=p>,</span> <span class=mi>820</span><span class=p>,</span> <span class=mi>655</span><span class=p>,</span> <span class=mi>526</span><span class=p>,</span> <span class=mi>423</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 5 */</span> <span class=mi>335</span><span class=p>,</span> <span class=mi>272</span><span class=p>,</span> <span class=mi>215</span><span class=p>,</span> <span class=mi>172</span><span class=p>,</span> <span class=mi>137</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 10 */</span> <span class=mi>110</span><span class=p>,</span> <span class=mi>87</span><span class=p>,</span> <span class=mi>70</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 15 */</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>23</span><span class=p>,</span> <span class=mi>18</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>优先级从 -20 到 19，数值越大优先级越低，默认优先级为 0，即对于默认优先级进程来说，实际运行时间与虚拟运行时间相等。</p><p>权重数值经过设计，当两个进程优先级之差一定时，其权重的比例也基本一定。例如 $\frac {weight_{-5}}{weight_0} = \frac {weight_0}{weight_{10}}$，即 3121/1024 = 1024/335。</p><p>进程以 <code>vruntime</code> 为键（实际以 <code>vruntime</code> 与最小的 <code>min_vruntime</code> 之差为键，因为虚拟运行时间是无符号整数）存储在红黑树中。</p><p>此外还有一个问题，当有新进程运行或者休眠进程唤醒时，其 <code>vruntime</code> 远小于正在运行的老进程，就会造成老进程饥饿，这时就要以 <code>min_vruntime</code> 为基础将 <code>vruntime</code> 设置一个合适的值。</p><h2 id=第-10-章-多处理器调度>第 10 章 多处理器调度</h2><p>将多个 CPU 组装在一块芯片上，这就是多核处理器。</p><p>在多处理器上工作主要有 3 个问题：</p><ol><li>缓存一致性问题。由于将缓存数据写回内存较慢，其他 CPU 读取到的内存会不一致。通过监控内存访问（如总线窥探），每个缓存都监听所有缓存和内存的总线，来发现内存访问，如果数据被更新，则将本地副本废弃或更新。</li><li>同步问题。需要使用互斥原语（如锁）保证正确性。</li><li>缓存亲和度问题。将进程切换到不同 CPU 上时，缓存也要重新加载。应尽量使进程保持在同一个 CPU 上。</li></ol><h3 id=104-单队列多处理器调度-sqms>10.4 单队列多处理器调度 SQMS</h3><p>简单复用单处理器调度的基本架构，将所有需要调度的作业放在一个单独的队列中，即单队列多处理器调度。</p><p>SQMS 的问题：</p><ol><li>缺乏扩展性。SQMS 访问单个队列，如果通过加锁来保证原子性，那么 CPU 数量扩展越多，带来的性能损失越大。</li><li>缓存亲和度。需要引入一些亲和性机制，尽量让进程在同一个 CPU 上运行。在保持一些作业亲和度的同时，可能需要牺牲其他作业的亲和度来实现负载均衡。</li></ol><h3 id=105-多队列多处理器调度-mqms>10.5 多队列多处理器调度 MQMS</h3><p>MQMS 每个 CPU 一个队列。具有良好的扩展性和缓存亲和度。</p><p>MQMS 存在负载不均的问题，部分 CPU 持续工作，部分 CPU 长时间闲置。需要通过迁移来实现负载均衡。</p><h3 id=106-linux-多处理器调度>10.6 Linux 多处理器调度</h3><p>O(1) 调度、CFS 调度采用多队列，前者类似 MLFQ，后者是确定的比例调度。</p><p>脑残调度（BFS 调度）采用单队列，也基于比例调度，适合交互性强的进程，例如桌面环境。</p><h2 id=参考资料>参考资料</h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://ppan-brian.medium.com/context-switch-from-xv6-aedcb1246cd target=_blank rel="noopener noreferrer">https://ppan-brian.medium.com/context-switch-from-xv6-aedcb1246cd</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href="http://linuxperf.com/?p=42" target=_blank rel="noopener noreferrer">http://linuxperf.com/?p=42</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><section class="article labels"><a class=tag href=/tags/ostep/>OSTEP</a><a class=tag href=/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a><a class=tag href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/get-next-for-kmp-algorithm/><span class="iconfont icon-article"></span>KMP 算法中的 next 数组</a></p><p><a class=link href=/posts/ostep-intro/><span class="iconfont icon-article"></span>OSTEP 介绍</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>