<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>文章&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><link rel=alternate type=application/rss+xml href=/posts/index.xml title=Binac><meta name=twitter:card content="summary">
<meta name=twitter:title content="文章"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><section class="article header"><h1>文章</h1></section><ul class="note list"><li class=item><a class=note href=/posts/csapp-data-lab/><p class="note title">CSAPP Data Lab</p><p class="note date">2020-07-02</p><p class="note content">Data Lab 的题1，第一眼觉得不难，仔细一看发现限制非常严格，比如只允许部分位运算符等，难度一下子就上去了，所以花了不少时间。
dlc 是 64 位 Linux 程序，使用 ./dlc bits.c 来检查是否符合限制条件。但 Makefile 里却指定了 -m32，可能是考虑到 C 标准只规定 int 至少为 16 位，一些环境可能会生成非 32 位的 int。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/csapp/>CSAPP</a><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a><a class=tag href=/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/>位操作</a></p></li><li class=item><a class=note href=/posts/shrink-disk-image/><p class="note title">缩减 IMG 镜像文件</p><p class="note date">2020-04-11</p><p class="note content">折腾 Armbian 时，下载的镜像文件 Armbian_20.05.1_Arm-64_bionic_current_5.6.2_20200408.img 是 5000MiB，而实际文件系统只占用了 2GiB 左右，说明存在大量冗余。
这是个非官方版本的 Armbian，作者看样子是个毛子，脾气大得很。我建议他缩小镜像，他说完全没必要。2GiB 的东西硬是搞到接近 5GiB，真是传统艺能。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/linux/>Linux</a></p></li><li class=item><a class=note href=/posts/state-pattern/><p class="note title">状态模式 State Pattern</p><p class="note date">2020-03-21</p><p class="note content">状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
《Head First 设计模式》举的例子是糖果机：糖果机定义了投币、退币、转动曲柄、发放糖果等行为，也有未投币、已投币、售出、已售罄等状态，可以使用 int 常量或枚举来标识这些状态。在客户端对糖果机发出请求时，糖果机内部每种行为都要使用大量的 if 语句进行状态判断和切换，不仅混乱，而且不利于扩展，例如新增一个状态就要大量修改原有代码。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/mediator-pattern/><p class="note title">中介者模式 Mediator Pattern</p><p class="note date">2020-03-19</p><p class="note content">在没有中介者的情况下，所有的对象都要认识其他对象，有了中介者后，对象只需要与中介者通信，对象之间彻底解耦。但是如果设计不当，中介者本身会过于复杂。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/observer-pattern/><p class="note title">观察者模式 Observer Pattern</p><p class="note date">2020-03-15</p><p class="note content">对象之间常有依赖关系，观察者模式可以让我们方便地监听一个对象，当它发生改变时，其他对象会自动收到通知并作出相应的反应。
实例 public class Subject { private int mState; private List&lt;Observer> mObservers = new ArrayList&lt;>(); public void setState(int state) { mState = state; notifyObservers(); } @Override public String toString() { return "State: " + mState; } public boolean addObserver(Observer o) { return mObservers.add(o); } public boolean removeObserver(Observer o) { return mObservers.remove(o); } private void notifyObservers() { for (Observer o : mObservers) { o.update(this); } } public interface Observer { void update(Subject subject); } } 测试 Subject subject = new Subject(); subject.setState(0); Subject.Observer so = System.out::println; subject.addObserver(so); subject.setState(1); subject.removeObserver(so); subject.setState(2); State: 1 实现源码 https://github.com/qianbinbin/DesignPattern/tree/master/src/main/java/io/binac/designpattern/observer
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/command-pattern/><p class="note title">命令模式 Command Pattern</p><p class="note date">2020-03-13</p><p class="note content">命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。
对这个设计模式的解读，网上一些文章存在误区。
实例 参与者 Receiver 接收者，知道如何实施与执行一个请求相关的操作。命名有误导性，有些文章把 Receiver 设计成接口，把它当成了类似观察者的角色，事实上 Receiver 应该是最终执行操作的类，任何类都可能作为一个接收者
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/proxy-pattern/><p class="note title">代理模式 Proxy Pattern</p><p class="note date">2020-03-10</p><p class="note content">客户端不能或不想直接使用一个类时，用代理模式可以实现间接使用。
代理模式一般指的是静态代理，即在编译时实现，代理类 SubjectProxy 与被代理的真实类 RealSubject 实现同一个 Subject 接口，SubjectProxy 维护一个 RealSubject 实例，客户端通过 SubjectProxy 来间接使用 RealSubject。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/flyweight-pattern/><p class="note title">享元模式 Flyweight Pattern</p><p class="note date">2020-03-08</p><p class="note content">享元模式与其说是一种设计模式，不如说是一种算法思想。将可以共享的对象存储在一个表中以节省内存，而不是每次都重新创建。
例如，Java 中的 Integer 类型对 -128 到 127 的值做了缓存，java.lang.Integer#valueOf(int) 会直接返回缓存的对象。String 则可以保存在常量池中。这些都是典型应用。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a></p></li></ul><div class=pagination><ul><li><a href=/posts/>1</a></li><li><a href=/posts/page/2/>2</a></li><li><a class=active href=/posts/page/3/>3</a></li><li><a href=/posts/page/4/>4</a></li><li><a href=/posts/page/5/>5</a></li><li><a href=/posts/page/4/><span class="iconfont icon-pagenext"></span></a></li></ul></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>