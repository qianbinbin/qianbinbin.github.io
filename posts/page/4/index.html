<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>文章&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><link rel=alternate type=application/rss+xml href=/posts/index.xml title=Binac><meta name=twitter:card content="summary">
<meta name=twitter:title content="文章"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><section class="article header"><h1>文章</h1></section><ul class="note list"><li class=item><a class=note href=/posts/facade-pattern/><p class="note title">外观模式 Facade Pattern</p><p class="note date">2020-03-07</p><p class="note content">将一个系统划分为若干子系统，有利于降低系统的复杂性，但是会使客户端的调用复杂化。
外观模式将这些子系统封装到一个类中，对客户端屏蔽这些子系统，提供一个高层、简单的接口。这也是我们不自觉就使用过的设计模式，只不过以前可能不知道名字而已。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/bridge-pattern/><p class="note title">桥接模式 Bridge Pattern</p><p class="note date">2020-03-06</p><p class="note content">当一个抽象可以有多个实现时，通常用继承来协调它们。
例如，对于表示形状的抽象类，可以有圆形、矩形等具体实现，但使用的绘图 API 实现可以不同，如果为每种形状类再定义各种 API 的版本，不仅复杂，而且抽象与实现绑定在一起，不能在运行时改变。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/adapter-pattern/><p class="note title">适配器模式 Adapter Pattern</p><p class="note date">2020-03-04</p><p class="note content">假设现有一个旧接口，客户端希望使用一种新接口的形式调用它，此时可以利用适配器模式，将旧接口以新接口的形式进行封装。不过如果适配器使用过多，则整个系统会显得混乱，因此最好只在希望避免修改原有代码时使用。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/rclone/><p class="note title">使用 Rclone 挂载网盘</p><p class="note date">2020-02-01</p><p class="note content">在没有图形界面的服务器上，或不想使用客户端软件时，如何方便地使用网盘是个问题。
Rclone 就是为此而生的，它可以方便在命令行下挂载网盘，目前已经支持包括 Google Drive、OneDrive 在内的几十个网盘，而且除了速度慢一点外，可以模拟本地磁盘，对于容量有限的 VPS 来说就是免费扩容，配合 aria2、Transmission 等工具，就可以打造离线下载服务器。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/linux/>Linux</a></p></li><li class=item><a class=note href=/posts/builder-pattern/><p class="note title">生成器模式 Builder Pattern</p><p class="note date">2020-01-29</p><p class="note content">在设计类时，如果包含或将来可能会包含很多属性，就要重载很多构造方法，不仅设计参数麻烦，调用也比较混乱。
为此可以使用 getter、setter 来逐步构造，但这样构造就分为很多步骤，但这可能会产生其它问题，比如维护者看到一部分代码会认为对象已经构造完毕，而实际上并非如此，使用未完全构造的对象就可能出错。另外这种方法也无法处理 final 字段。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/strategy-pattern/><p class="note title">策略模式 Strategy Pattern</p><p class="note date">2020-01-27</p><p class="note content">在软件开发中，某一功能可以有多种实现，如果把这些实现都放在一个类中，则不利于增加、修改和替换，此时可以把可能频繁变化的逻辑抽象出来，Runnable 就采用了类似的思想。这种设计模式叫策略模式：
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/cross-compile-samba-for-ios/><p class="note title">移植 Samba 到 iOS 平台</p><p class="note date">2019-09-08</p><p class="note content">前言 iOS 越狱后可以像树莓派那样作为迷你服务器，在上面搭建 aria2、Transmission 等。但是 Cydia 上的 Samba 非常古老，而且只能在 32 位 CPU 上运行。
于是我开始寻找替代方案：
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/ios/>iOS</a><a class=tag href=/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/>交叉编译</a></p></li><li class=item><a class=note href=/posts/cross-compile-frp-for-ios/><p class="note title">交叉编译 Go 语言项目 frp for iOS</p><p class="note date">2019-09-03</p><p class="note content">首先安装 Go 语言环境，然后下载 frp 源码：
git clone git@github.com:fatedier/frp.git cd frp Go 的交叉编译比 GCC、Clang 方便很多，只需要设置几个参数：
CC=$GOPATH/misc/ios/clangwrap.sh CGO_ENABLED=1 GOOS=darwin GOARCH=arm64 go build -o ./frpc-darwin-arm64 ./cmd/frpc CC=$GOPATH/misc/ios/clangwrap.sh CGO_ENABLED=1 GOOS=darwin GOARCH=arm64 go build -o ./frps-darwin-arm64 ./cmd/frps GOOS 参数没什么疑问，GOARCH 不是太古老的设备一般都是 arm64。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/ios/>iOS</a><a class=tag href=/tags/go/>Go</a><a class=tag href=/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/>交叉编译</a></p></li></ul><div class=pagination><ul><li><a href=/posts/>1</a></li><li><a href=/posts/page/2/>2</a></li><li><a href=/posts/page/3/>3</a></li><li><a class=active href=/posts/page/4/>4</a></li><li><a href=/posts/page/5/>5</a></li><li><a href=/posts/page/5/><span class="iconfont icon-pagenext"></span></a></li></ul></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>