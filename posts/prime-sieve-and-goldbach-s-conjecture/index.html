<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>素数筛法和哥德巴赫猜想&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="素数筛法和哥德巴赫猜想"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">素数筛法和哥德巴赫猜想</h1><p class="article date">2019-01-03</p></section><article class="article markdown-body"><p>起因是看到了这个帖子<a href=https://www.zhihu.com/question/306537777 target=_blank rel="noopener noreferrer">如果高中生能证明哥德巴赫猜想，会被清华北大数学系保送吗？ - 知乎</a>，emmm&mldr;</p><p>本文的目标是筛选 32 位无符号整数（约 40 亿）中的所有素数，并在此范围内验证哥德巴赫猜想。</p><h2 id=试除法>试除法</h2><p>一开始并没有打算寻找所有素数，而是暴力判断是否为素数。一个小技巧是将自然数表示为 6k + b，当中只有 6k + 1 和 6k + 5 的形式可能为素数。也可以用 30k + b 等，简单起见不再优化了。</p><p>后来发现我还是 naive，验证所有的 32 位无符号整数耗时太长，验证到 1000 万都要 10 秒左右。</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/prime-sieve-and-goldbach-s-conjecture/trial_division.c style=color:lightslategrey;font-size:.8em>trial_division.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>prime</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>number</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>number</span> <span class=o>&lt;</span> <span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>number</span> <span class=o>==</span> <span class=mi>2</span> <span class=o>||</span> <span class=n>number</span> <span class=o>==</span> <span class=mi>3</span> <span class=o>||</span> <span class=n>number</span> <span class=o>==</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>number</span> <span class=o>%</span> <span class=mi>6</span> <span class=o>!=</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>number</span> <span class=o>%</span> <span class=mi>6</span> <span class=o>!=</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=n>sq</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span> <span class=nf>sqrt</span><span class=p>(</span><span class=n>number</span><span class=p>);</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>sq</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>number</span> <span class=o>%</span> <span class=n>i</span><span class=p>)</span> <span class=o>||</span> <span class=o>!</span><span class=p>(</span><span class=n>number</span> <span class=o>%</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>2</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><h2 id=埃拉托斯特尼筛法>埃拉托斯特尼筛法</h2><p>如果能先求得所有素数，然后查表，速度会有很大提升。</p><p>对于每个整数使用一个 bit 来标识是否为素数，32 位无符号整数需要 2^32 / 8 = 512 MiB 空间，剔除所有的偶数，需要一半即 256 MiB。如果剔除 6k + 1 和 6k + 5 以外的数，只需要 1/3 的空间，但是不利于映射时使用位操作，故只剔除偶数。</p><p>经了解，筛选素数常见的有两种方法：埃拉托斯特尼筛法和欧拉筛法。前者思路简单，且无需保存素数序列，时间复杂度为 $O(n \log \log n)$；后者需要保存素数序列，时间复杂度为 $O(n)$。</p><p>所谓埃氏筛法，就是筛去 $\le \sqrt{n}$ 的素数 $2, 3, 5, &mldr;$ 的倍数，维基百科的图片清晰易懂：</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif alt></p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/prime-sieve-and-goldbach-s-conjecture/sieve_of_eratosthenes.c style=color:lightslategrey;font-size:.8em>sieve_of_eratosthenes.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>prime</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>n</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>!</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>)));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sieve_of_eratosthenes</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>n</span><span class=p>,</span> <span class=n>sq</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>step</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=n>sq</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span> <span class=nf>sqrt</span><span class=p>(</span><span class=n>UINT32_MAX</span><span class=p>);</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=n>sq</span><span class=p>;</span> <span class=n>n</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>start</span> <span class=o>=</span> <span class=n>n</span> <span class=o>*</span> <span class=n>n</span><span class=p>,</span> <span class=n>step</span> <span class=o>=</span> <span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>,</span> <span class=n>c</span> <span class=o>=</span> <span class=n>start</span><span class=p>;</span> <span class=n>c</span> <span class=o>&gt;=</span> <span class=n>start</span><span class=p>;</span> <span class=n>c</span> <span class=o>+=</span> <span class=n>step</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>data</span><span class=p>[</span><span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>|=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>这里除了位操作外，还用到一些优化：</p><ul><li>当筛选素数 $n$ 的倍数时，$2n, 3n, &mldr;, (n-1)n$ 必然已经筛选过了，故只需从 $n^2$ 开始，于是筛选序列为 $n^2, n^2 + n, n^2 + 2n&mldr;$</li><li>当 $k$ 为奇数时，由于 $n$ 为奇数，则 $n^2 + kn$ 必为偶数，算法只对奇数保存标识，故 $k$ 只需取偶数，筛选序列只剩下 $n^2, n^2 + 2n, n^2 + 4n&mldr;$</li></ul><p>在 i7-7700HQ + 16 GiB 内存的 MacBook Pro 上，开启 O3 优化后耗时约 22 秒：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Sieve of Eratosthenes cost 21.723315 seconds.
</span></span><span class=line><span class=cl>Same story.
</span></span><span class=line><span class=cl>Verification cost 63.079718 seconds.
</span></span></code></pre></div><p>这个算法的主要缺陷是，不利于 CPU 利用程序的局部性原理。筛选的时候 <code>data</code> 数组并不是按顺序读写的，而是类似列优先读写二维数组那样，cache 命中率太低，大量耗时都用在了读写内存上。</p><h2 id=分段埃氏筛法>分段埃氏筛法</h2><p>cache 命中率对程序速度有很大影响，于是有了分段筛选。</p><p>在 32 位无符号整数范围内，埃氏筛法需要筛掉 <code>sqrt(UINT32_MAX)</code> 以内的素数的倍数。根据<a href=https://zh.wikipedia.org/wiki/%E7%B4%A0%E6%95%B0%E8%AE%A1%E6%95%B0%E5%87%BD%E6%95%B0 target=_blank rel="noopener noreferrer">素数计数函数</a>，在此范围内的素数约有 8000 个，保存只需占用约 32 KiB，不再像上面那样查询 <code>data</code> 数组。</p><p>将 32 位无符号整数划分为若干个等长的段，先使用埃氏筛法筛选第一个段，并收集 <code>sqrt(UINT32_MAX)</code> 以内的素数，对其它段筛选前若干个素数的倍数。数据段不宜过大，否则 cache 命中率会降低，但也不宜过小，否则复杂度也会增大。</p><p>i7-7700HQ 的 L1 数据 cache 大小为 32 KiB，L2 cache 为 256 KiB，L3 cache 为 6 MiB。在实践中，发现选择 128 KiB 作为一个段大小较为合适。</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/prime-sieve-and-goldbach-s-conjecture/segmented_sieve_of_eratosthenes.c style=color:lightslategrey;font-size:.8em>segmented_sieve_of_eratosthenes.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Note: the size must be power of 2.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define SEGMENT_SIZE 0x200000
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 32 KiB L1 data cache = 2^15*2^3 = 2^18 bits, identifying 2^19 numbers.
</span></span></span><span class=line><span class=cl><span class=c1>// #define SEGMENT_SIZE 0x80000
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 256 KiB L2 cache
</span></span></span><span class=line><span class=cl><span class=c1>// #define SEGMENT_SIZE 0x400000
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 6 MiB L3 cache, use 2 MiB of it
</span></span></span><span class=line><span class=cl><span class=c1>// #define SEGMENT_SIZE 0x2000000
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>prime</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>n</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>!</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>)));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Run sieve of Eratosthenes in [0, max(SEGMENT_SIZE, sqrt(UINT32_MAX))),
</span></span></span><span class=line><span class=cl><span class=cm> * and store prime numbers in [3, sqrt(UINT32_MAX)].
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>initial_sieve</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>primes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>SQ</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span> <span class=nf>sqrt</span><span class=p>(</span><span class=n>UINT32_MAX</span><span class=p>),</span> <span class=n>LIMIT</span> <span class=o>=</span> <span class=n>SEGMENT_SIZE</span> <span class=o>&gt;</span> <span class=n>SQ</span> <span class=o>?</span> <span class=nl>SEGMENT_SIZE</span> <span class=p>:</span> <span class=n>SQ</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>n</span><span class=p>,</span> <span class=n>sq</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>step</span><span class=p>,</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=n>sq</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span> <span class=nf>sqrt</span><span class=p>(</span><span class=n>LIMIT</span><span class=p>);</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=n>sq</span><span class=p>;</span> <span class=n>n</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>c</span> <span class=o>=</span> <span class=n>n</span> <span class=o>*</span> <span class=n>n</span><span class=p>,</span> <span class=n>step</span> <span class=o>=</span> <span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>;</span> <span class=n>c</span> <span class=o>&lt;=</span> <span class=n>LIMIT</span><span class=p>;</span> <span class=n>c</span> <span class=o>+=</span> <span class=n>step</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>data</span><span class=p>[</span><span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>|=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=n>SQ</span><span class=p>;</span> <span class=n>n</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>            <span class=n>primes</span><span class=p>[</span><span class=n>count</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>segmented_sieve_of_eratosthenes</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// store prime numbers in [3, sqrt(UINT32_MAX)]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>primes</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8192</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>count</span> <span class=o>=</span> <span class=nf>initial_sieve</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>primes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>sq</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>step</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>SEGMENTS</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>31</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>SEGMENT_SIZE</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// first segment has been sieved
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>low</span> <span class=o>=</span> <span class=n>SEGMENT_SIZE</span><span class=p>,</span> <span class=n>high</span> <span class=o>=</span> <span class=p>(</span><span class=n>SEGMENT_SIZE</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=n>s</span> <span class=o>&lt;</span> <span class=n>SEGMENTS</span><span class=p>;</span> <span class=o>++</span><span class=n>s</span><span class=p>,</span> <span class=n>low</span> <span class=o>+=</span> <span class=n>SEGMENT_SIZE</span><span class=p>,</span> <span class=n>high</span> <span class=o>+=</span> <span class=n>SEGMENT_SIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sq</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span> <span class=nf>sqrt</span><span class=p>(</span><span class=n>high</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>p</span> <span class=o>=</span> <span class=n>primes</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>&lt;=</span> <span class=n>sq</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// c = p^2 + 2k * p
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>c</span> <span class=o>=</span> <span class=n>low</span> <span class=o>/</span> <span class=n>p</span> <span class=o>*</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>&lt;</span> <span class=n>low</span><span class=p>)</span> <span class=n>c</span> <span class=o>+=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>c</span> <span class=o>%</span> <span class=mi>2</span><span class=p>))</span> <span class=n>c</span> <span class=o>+=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// uint32t overflow in last segment
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=n>step</span> <span class=o>=</span> <span class=n>p</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>;</span> <span class=n>low</span> <span class=o>&lt;=</span> <span class=n>c</span> <span class=o>&amp;&amp;</span> <span class=n>c</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>;</span> <span class=n>c</span> <span class=o>+=</span> <span class=n>step</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>data</span><span class=p>[</span><span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>|=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>primes</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>速度有了明显的提升：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Segmented sieve of Eratosthenes cost 5.576287 seconds.
</span></span><span class=line><span class=cl>Same story.
</span></span><span class=line><span class=cl>Verification cost 63.089097 seconds.
</span></span></code></pre></div><p>这里对每个素数都计算其倍数 <code>c</code>，也可以将所有素数的倍数保存到一个数组中，与 <code>primes</code> 数组一样只占 32 KiB，这样每次无需重新计算。但在实践中发现性能反而下降了一点，推测是仅仅几千个数的乘除和加法 * 段数，耗时并不多，而内存读写已经超过了这个耗时。</p><h2 id=欧拉筛法>欧拉筛法</h2><p>在埃氏筛法中，一个合数会被多次筛选到，因此它不是线性的算法。欧拉筛法使每个合数只被其最小质因数筛去一次，其复杂度为 $O(n)$，在数量很大时有很大优势。</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/prime-sieve-and-goldbach-s-conjecture/sieve_of_euler.c style=color:lightslategrey;font-size:.8em>sieve_of_euler.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>prime</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>n</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>!</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>)));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sieve_of_euler</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>primes</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8192</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>SQ</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span> <span class=nf>sqrt</span><span class=p>(</span><span class=n>UINT32_MAX</span><span class=p>),</span> <span class=n>LIMIT_N</span> <span class=o>=</span> <span class=n>UINT32_MAX</span> <span class=o>/</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>LIMIT_P</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=n>LIMIT_N</span><span class=p>;</span> <span class=n>n</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=n>SQ</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>            <span class=n>primes</span><span class=p>[</span><span class=n>count</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>LIMIT_P</span> <span class=o>=</span> <span class=n>UINT32_MAX</span> <span class=o>/</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>p</span> <span class=o>=</span> <span class=n>primes</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>&lt;=</span> <span class=n>LIMIT_P</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span> <span class=o>=</span> <span class=n>p</span> <span class=o>*</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>data</span><span class=p>[</span><span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>]</span> <span class=o>|=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=n>p</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>primes</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>关键在当 <code>n</code> 是素数 <code>p</code> 的倍数时直接 <code>break</code>。</p><p>算法的正确性（所有合数都能被筛去）：对于任意合数 $c$，将其写成质因数乘积 $c = p_1^{k_1} p_2^{k_2}&mldr; p_j^{k_j}$，$c$ 一定能在 $n = p_1^{k_1 - 1} p_2^{k_2}&mldr; p_j^{k_j}$ 被筛去，因为 $n \ge p_1$，即素数 $p_1$ 必然已经被收集。</p><p>算法的复杂度（合数只被最小质因数筛去一次）：假设合数 $c = p_1^{k_1} p_2^{k_2}&mldr; p_x^{k_x}&mldr; p_j^{k_j}$ 也被 $p_x$ 筛去，此时 $n = p_1^{k_1} p_2^{k_2}&mldr; p_x^{k_x - 1}&mldr; p_j^{k_j}$。若 $n &lt; p_x$，此时 $p_x$ 还没被收集，不符合；若 $n \ge p_x$，之前的循环中已经枚举了 $p_1, p_2&mldr;, p_i$，在 $p_1$ 的时候就 <code>break</code> 了，故不符合。</p><p>虽然是线性复杂度，实际运行好于埃氏筛法，但比起分段埃氏筛法还是慢很多：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Sieve of Euler cost 15.921141 seconds.
</span></span><span class=line><span class=cl>Same story.
</span></span><span class=line><span class=cl>Verification cost 63.412436 seconds.
</span></span></code></pre></div><p>而欧拉筛法本身又不适合改写成分段算法，看来 cache 的威力还是相当可观的。</p><h2 id=总结>总结</h2><p>试除法适用于数据较小的情况，埃氏筛法和欧拉筛法适用于数据较大的情况。如果对性能要求较高，可以考虑分段埃氏筛法。</p><h2 id=参考资料>参考资料</h2><ol><li><a href=https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95 target=_blank rel="noopener noreferrer">埃拉托斯特尼筛法 - 维基百科，自由的百科全书</a></li><li><a href=https://primesieve.org/segmented_sieve.html target=_blank rel="noopener noreferrer">primesieve - Segmented sieve of Eratosthenes</a></li><li><a href=http://debug18.com/posts/introduction-to-sieve-method/ target=_blank rel="noopener noreferrer">筛法小结 (Eratosthenes/Euler) | __debug&rsquo;s Home</a></li></ol></article><section class="article labels"><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a><a class=tag href=/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/>位操作</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/java-collections-framework/><span class="iconfont icon-article"></span>Java 集合框架</a></p><p><a class=link href=/posts/csapp-representing-and-manipulating-information/><span class="iconfont icon-article"></span>CSAPP 信息的表示和处理</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>