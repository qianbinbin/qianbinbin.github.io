<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>在 Java 中使用 Map 计数的几种姿势&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="在 Java 中使用 Map 计数的几种姿势"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">在 Java 中使用 Map 计数的几种姿势</h1><p class="article date">2018-06-02</p></section><article class="article markdown-body"><p>一个老生常谈的问题：在 Java 中，如何使用 Map 给对象计数，例如统计字符串出现的次数？</p><h2 id=姿势一containskey>姿势一：containsKey()</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>word</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>words</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>map</span><span class=p>.</span><span class=na>containsKey</span><span class=p>(</span><span class=n>word</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>word</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>else</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>或者：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>containsKey</span><span class=p>(</span><span class=n>word</span><span class=p>)</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>word</span><span class=p>)</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>这是最容易想到的方法，然而这种方法至少有两个问题：</p><ol><li><p>Integer 中的 <code>value</code> 声明为 <code>final</code>，无法修改，每次更新均会产生一个新的 Integer 对象</p></li><li><p>过于频繁且不必要的查表，具体来说，在 <code>map</code> 中不含有 <code>word</code> 的情况下会查两次表，分别是 <code>containsKey()</code>、<code>put()</code> 方法；在含有 <code>word</code> 的情况下会查三次表，分别为 <code>containsKey()</code>、<code>get()</code>、<code>put()</code> 方法</p></li></ol><h2 id=姿势二get--getordefault>姿势二：get() / getOrDefault()</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Integer</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>word</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>count</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>else</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Java 8 则可以用 <code>getOrDefault()</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>getOrDefault</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol><li><p>Integer 对象问题仍存在</p></li><li><p>改善了查表问题，不管 <code>map</code> 中是否已经存在 <code>word</code>，都只查两次表</p></li></ol><h2 id=姿势三atomicinteger--自定义可变-int-封装类>姿势三：AtomicInteger / 自定义可变 int 封装类</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>AtomicInteger</span><span class=o>&gt;</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>AtomicInteger</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>word</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>count</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicInteger</span><span class=p>(</span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>else</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>count</span><span class=p>.</span><span class=na>incrementAndGet</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>利用 AtomicInteger，可以避免产生不必要的 Integer 对象。</p><p>也可以自己封装一个 MutableInt：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MutableInt</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>increment</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>++</span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>get</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>AtomicInteger 是为线程安全设计的，可能有一定性能损失，但我实际测试发现，AtomicInteger 与自己封装类的性能表现几乎相同。</p><ol><li><p>解决了 Integer 对象问题</p></li><li><p>改善了查表问题，每次只查两次表</p></li></ol><h2 id=姿势四利用-put-方法的返回值>姿势四：利用 put() 方法的返回值</h2><p>Map 的 <code>put()</code> 方法返回的是之前对应键的值，如果不存在，则为 <code>null</code>。</p><p>利用这一点就可以只查表一次即完成自增了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>AtomicInteger</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicInteger</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>AtomicInteger</span><span class=w> </span><span class=n>old</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>count</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>old</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>count</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>old</span><span class=p>.</span><span class=na>get</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol><li><p>每次仍产生一个冗余的 int 封装对象</p></li><li><p>只查表一次，大大提高效率</p></li></ol><h2 id=姿势五java-8-中的-merge--compute>姿势五：Java 8 中的 merge() / compute()</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>map</span><span class=p>.</span><span class=na>merge</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>或者：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>map</span><span class=p>.</span><span class=na>merge</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=p>::</span><span class=n>sum</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>也可以用 <code>compute()</code> 方法实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>map</span><span class=p>.</span><span class=na>compute</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>虽然 Integer 对象问题仍存在，但只查一次表就实现了自增，Integer 自动拆箱装箱机制使代码非常简洁，如果使用 Java 8，毫无疑问代替姿势四。</p><p>当然 Integer 问题也是可以解决的，例如我们使用 AtomicInteger：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>map</span><span class=p>.</span><span class=na>compute</span><span class=p>(</span><span class=n>word</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>v</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicInteger</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>v</span><span class=p>.</span><span class=na>incrementAndGet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>v</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></div><p>只不过代码没那么简洁了，这样既解决了 Integer 对象问题，又减少了查表时间。</p><h2 id=总结>总结</h2><p>以下是我个人测试得到的性能表现：</p><p>在字符串重复率较高的情况下，姿势三 > 姿势五 > 姿势二 > 姿势四 > 姿势一</p><p>在重复率较低的情况下，姿势五 > 姿势二 > 姿势四 > 姿势一 > 姿势三</p><p>基本符合预期。</p><ul><li><p>姿势一表现一直都较差</p></li><li><p>姿势二中规中矩，很多人也确实就是这样写的</p></li><li><p>姿势三避免了创建冗余对象，在重复率较高的情况下表现非常好，甚至好于姿势五</p></li><li><p>姿势四则比较奇葩，看似做了优化，但产生的冗余对象拖了后腿，代码可读性也不如其它，不建议使用</p></li><li><p>姿势五不管重复率如何整体表现都很稳定，代码也很简洁，如果不是量很大，那么使用封装类相比 Integer 优势不明显</p></li></ul><p>以上均不考虑线程安全。</p><h2 id=参考资料>参考资料</h2><ol><li><a href=https://stackoverflow.com/questions/81346/most-efficient-way-to-increment-a-map-value-in-java target=_blank rel="noopener noreferrer">optimization - Most efficient way to increment a Map value in Java - Stack Overflow</a></li><li><a href=https://stackoverflow.com/questions/4277388/increment-an-integer-within-a-hashmap/37296348 target=_blank rel="noopener noreferrer">java - Increment an Integer within a HashMap - Stack Overflow</a></li></ol></article><section class="article labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/>哈希表</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/first-missing-positive/><span class="iconfont icon-article"></span>数组中首个缺失的正整数 First Missing Positive</a></p><p><a class=link href=/posts/leetcode-categories/><span class="iconfont icon-article"></span>LeetCode 个人分类</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>