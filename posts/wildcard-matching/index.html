<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>通配符匹配 Wildcard Matching&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><meta name=twitter:card content="summary">
<meta name=twitter:title content="通配符匹配 Wildcard Matching"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item active' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">通配符匹配 Wildcard Matching</h1><p class="article date">2018-06-12</p></section><article class="article markdown-body"><p>通配符匹配问题：
<a href=https://leetcode.com/problems/wildcard-matching/ target=_blank rel="noopener noreferrer">https://leetcode.com/problems/wildcard-matching/</a></p><blockquote><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &lsquo;?&rsquo; and &lsquo;*&rsquo;.</p><p>&lsquo;?&rsquo; Matches any single character.
&lsquo;*&rsquo; Matches any sequence of characters (including the empty sequence).</p><p>The matching should cover the entire input string (not partial).</p><p>Note:</p><p>s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like ? or *.</p></blockquote><p>待匹配字串 <code>s</code> 中只有字母，模式串中 <code>p</code> 只含有字母和 <code>?</code>、<code>*</code>，<code>?</code> 匹配任意单个字符，<code>*</code> 匹配任意多个字符（包括空字串），判断字串是否完全匹配。</p><p>使用递归算法会超时。</p><h2 id=动态规划>动态规划</h2><p>设 $f(i, j)$ 表示 <code>s</code> 前 $i$ 个字符与 <code>p</code> 前 $j$ 个字符是否匹配，当 $i \le 1$ 时不难写出递推公式：</p><p>$$f(i, j) = \begin{cases} false & \text{s[i - 1] 与 p[j - 1] 不匹配} \\ f(i - 1, j - 1) & \text{s[i - 1] 与 p[j - 1] 匹配} \\ f(i, j - 1) 或 f(i - 1, j) & \text{p[i - 1] 为 *} \end{cases}$$</p><p>对边界情况提前做特殊处理即可。C 语言实现：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/leetcode/c/src/wildcard_matching.c style=color:lightslategrey;font-size:.8em>c/src/wildcard_matching.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>isMatch_44_1</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=k>const</span> <span class=n>m</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>),</span> <span class=n>n</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=o>**</span><span class=n>match</span> <span class=o>=</span> <span class=p>(</span><span class=kt>bool</span> <span class=o>**</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>((</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>bool</span> <span class=o>*</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>match</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>bool</span> <span class=o>*</span><span class=p>)</span> <span class=nf>calloc</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>bool</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>match</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;*&#39;</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>match</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;?&#39;</span> <span class=o>||</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>match</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>match</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;*&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>match</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>match</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>||</span> <span class=n>match</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>match</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=n>n</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=nf>free</span><span class=p>(</span><span class=n>match</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>match</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>时间复杂度为 $O(mn)$。</p><h2 id=贪心法>贪心法</h2><p>递归版本实现可能出现以下逻辑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;*&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>match</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>||</span> <span class=nf>match</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span></code></pre></div><p>这里 <code>match(i, j)</code> 表示从 <code>s[i]</code>、<code>p[j]</code> 开始是否匹配。</p><p>可见，每当遇到一个 <code>*</code>，都会产生新的分支。</p><p>而贪心法只对模式串上一个（已扫描部分的最后一个）<code>*</code> 进行继续搜索，只需记录上一个 <code>*</code> 指针即可。</p><p>C 语言实现：</p><figure style="margin:0 0 1.5em"><figcaption style=text-align:right><a href=/code/leetcode/c/src/wildcard_matching.c style=color:lightslategrey;font-size:.8em>c/src/wildcard_matching.c</a></figcaption><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>isMatch_44_2</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>star</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>*</span><span class=n>last_s</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>*</span><span class=n>s</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span> <span class=o>==</span> <span class=sc>&#39;?&#39;</span> <span class=o>||</span> <span class=o>*</span><span class=n>p</span> <span class=o>==</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span> <span class=o>==</span> <span class=sc>&#39;*&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>last_s</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>star</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>star</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span> <span class=o>=</span> <span class=o>++</span><span class=n>last_s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span> <span class=o>=</span> <span class=n>star</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span> <span class=o>==</span> <span class=sc>&#39;*&#39;</span><span class=p>)</span> <span class=o>++</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=n>p</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></figure><p>这样，分支明显少于递归版本。</p><p>以下是不严格说明：</p><pre tabindex=0><code>            i
[match][*]abc[*][to match]
[match] * abc * [to match]
</code></pre><p>第一行为 <code>s</code>，第二行为 <code>p</code>。<code>[match]</code> 表示已匹配子串，<code>[to match]</code> 表示待匹配子串。<code>s</code> 中的 <code>[*]</code> 与 <code>p</code> 中的 <code>*</code> 匹配。<code>abc</code> 是一段匹配的字符串（可能含有 <code>?</code>）。</p><p>设 <code>s</code> 中 <code>c</code> 的下标为 <code>i</code>。如果回溯第一个 <code>*</code>，即让它匹配更长的子串，则新匹配（如果有的话）的 <code>c</code> 位置一定在 <code>i</code> 之后，它可能在 <code>[*]</code> 中，也可能在 <code>[to match]</code> 中，但无论如何，这些情况都被“只回溯第二个 <code>*</code> ”包括在内了。因此，只回溯最后一个 <code>*</code> 就可以了。</p><p>在最坏情况下，这一算法的时间复杂度也为 $O(mn)$。</p><h2 id=实现源码>实现源码</h2><p><a href=https://github.com/qianbinbin/leetcode target=_blank rel="noopener noreferrer">https://github.com/qianbinbin/leetcode</a></p><h2 id=参考资料>参考资料</h2><ol><li><a href=https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution target=_blank rel="noopener noreferrer">Wildcard Matching - LeetCode</a></li></ol></article><section class="article labels"><a class=tag href=/tags/leetcode/>LeetCode</a><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a><a class=tag href=/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/>动态规划</a><a class=tag href=/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/>贪心算法</a></section><section class="article license"><p xmlns:cc=http://creativecommons.org/ns# style=text-align:center>本作品根据 <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel="license noopener noreferrer" style=display:inline-block>署名-非商业性使用-相同方式共享 4.0 国际许可<img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/cc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/by.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/nc.svg><img style=height:15px!important;margin-left:1px;vertical-align:text-bottom src=/cc-icons/sa.svg></a> 进行授权。</p></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/first-power-of-two-equal-to-or-greater-than-an-integer/><span class="iconfont icon-article"></span>第一个大于等于某个正整数的 2 的幂</a></p><p><a class=link href=/posts/first-missing-positive/><span class="iconfont icon-article"></span>数组中首个缺失的正整数 First Missing Positive</a></p></section><section class="article discussion"><script>function loadComment(){let e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","qianbinbin/qianbinbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","preferred-color-scheme"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()})</script></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>