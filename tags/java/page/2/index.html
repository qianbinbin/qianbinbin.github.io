<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.136.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><link rel=icon href=/favicons/favicon.svg><title>Java&nbsp;&ndash;&nbsp;Binac</title><link rel=stylesheet href=/css/core.min.d30edcc615d78b7f8a2a9e5f1b66bd074a7ad2e94b579fa5902d0967ce0f7684b300ef3a9e15d41af82c75f3fb951d4b.css integrity=sha384-0w7cxhXXi3+KKp5fG2a9B0p60ulLV5+lkC0JZ84PdoSzAO86nhXUGvgsdfP7lR1L><link rel=alternate type=application/rss+xml href=/tags/java/index.xml title=Binac><meta name=twitter:card content="summary">
<meta name=twitter:title content="Java"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/favicons/favicon.svg alt><span class="site name">Binac</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class='nav item' href=/posts/ title=文章>文章</a>
<a class='nav item' href=/nonsense/ title=妄言>妄言</a>
<a class='nav item' href=/tuya/ title=涂鸦>涂鸦</a>
<a class='nav item' href=/tags/ title>标签</a></nav></div></span></div></section><section id=content><section class="article header"><h1>Java</h1></section><ul class="note list"><li class=item><a class=note href=/posts/adapter-pattern/><p class="note title">适配器模式 Adapter Pattern</p><p class="note date">2020-03-04</p><p class="note content">假设现有一个旧接口，客户端希望使用一种新接口的形式调用它，此时可以利用适配器模式，将旧接口以新接口的形式进行封装。不过如果适配器使用过多，则整个系统会显得混乱，因此最好只在希望避免修改原有代码时使用。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/builder-pattern/><p class="note title">生成器模式 Builder Pattern</p><p class="note date">2020-01-29</p><p class="note content">在设计类时，如果包含或将来可能会包含很多属性，就要重载很多构造方法，不仅设计参数麻烦，调用也比较混乱。
为此可以使用 getter、setter 来逐步构造，但这样构造就分为很多步骤，但这可能会产生其它问题，比如维护者看到一部分代码会认为对象已经构造完毕，而实际上并非如此，使用未完全构造的对象就可能出错。另外这种方法也无法处理 final 字段。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/strategy-pattern/><p class="note title">策略模式 Strategy Pattern</p><p class="note date">2020-01-27</p><p class="note content">在软件开发中，某一功能可以有多种实现，如果把这些实现都放在一个类中，则不利于增加、修改和替换，此时可以把可能频繁变化的逻辑抽象出来，Runnable 就采用了类似的思想。这种设计模式叫策略模式：
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/java-collections-framework/><p class="note title">Java 集合框架</p><p class="note date">2019-04-17</p><p class="note content">Collection Collection 接口基本可分为三种，List、Set 和 Queue。这些接口有对应实现的抽象类，实体类只需要继承抽象类即可，免去不必要的重复编码。
为什么实体类继承了对应的抽象类，还要实现接口呢？例如：
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a></p></li><li class=item><a class=note href=/posts/use-map-to-count-in-java/><p class="note title">在 Java 中使用 Map 计数的几种姿势</p><p class="note date">2018-06-02</p><p class="note content">一个老生常谈的问题：在 Java 中，如何使用 Map 给对象计数，例如统计字符串出现的次数？
姿势一：containsKey() Map&lt;String, Integer> map = new HashMap&lt;>(); for (String word : words) { if (map.containsKey(word)) map.put(word, map.get(word) + 1); else map.put(word, 1); } 或者：
int count = map.containsKey(word) ? map.get(word) : 0; map.put(word, count + 1); 这是最容易想到的方法，然而这种方法至少有两个问题：
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/>哈希表</a></p></li><li class=item><a class=note href=/posts/factory-pattern/><p class="note title">工厂模式 Factory Pattern</p><p class="note date">2017-09-09</p><p class="note content">工厂模式可分为简单工厂模式 Simple Factory Pattern、工厂方法模式 Factory Method Pattern 和 抽象工厂模式 Abstract Factory Pattern。
简单工厂模式 简单工厂模式实际上是对产品创建逻辑做了统一的封装，包含如下角色：
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li><li class=item><a class=note href=/posts/print-log-in-libcore/><p class="note title">在 Android Java 核心库 libcore 中打印 Log</p><p class="note date">2017-08-30</p><p class="note content">Android Java 核心库中是无法直接使用 android.util.Log 的，添加后编译不通过，因为 framework 中的 Java API 依赖于 Java 核心库。
在 Android 7.0 之前，Java 核心库源码在libcore/luni/下，luni 代表 lang、util、net、io，是 Java 中最常见的包；Android 7.0 中，核心库在libcore/ojluni/下，oj 代表 OpenJDK。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/android/>Android</a><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/jni/>JNI</a></p></li><li class=item><a class=note href=/posts/decorator-pattern/><p class="note title">装饰器模式 Decorator Pattern</p><p class="note date">2017-06-22</p><p class="note content">在面向对象编程中，要扩展一个类或对象的功能，可以使用继承机制。
举例来说，咖啡店可能会提供拿铁、卡布奇诺、美式咖啡、意式浓缩等供客人选择，我们可以先定义一个 Coffee 类，并在其中声明价格、成分等方法，然后为每种咖啡继承它：Latte、Cappuccino、Americano、Espresso 等，每个类中都实现自己的一套价格、成分信息，这些类都是预先定义好的。
<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=tag href=/tags/java/>Java</a><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></p></li></ul><div class=pagination><ul><li><a href=/tags/java/>1</a></li><li><a class=active href=/tags/java/page/2/>2</a></li><li><a href=/tags/java/page/3/>3</a></li></ul></div></section><section id=footer><div class=footer-wrap><p class=copyright>© 2017-2024 Binac.</p></div></section><script async src="https://www.googletagmanager.com/gtag/js?id=G-N7VZY53PLB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N7VZY53PLB")}</script><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script><script>addBackToTop({diameter:42})</script></body></html>